# 单元测试文档 — VEX V5 机器人

---

## 目录

1. [什么是单元测试？](#1-什么是单元测试)
2. [我们的测试方法](#2-我们的测试方法)
3. [如何运行测试](#3-如何运行测试)
4. [测试框架详解](#4-测试框架详解)
5. [模拟硬件层](#5-模拟硬件层)
6. [PID控制器测试](#6-pid控制器测试)
7. [运动规划测试](#7-运动规划测试)
8. [里程计测试](#8-里程计测试)
9. [如何添加新测试](#9-如何添加新测试)
10. [故障排查](#10-故障排查)

---

## 1. 什么是单元测试？

**单元测试**是对一小段代码（一个"单元"）进行隔离测试。就像在搭建整座城堡之前，先测试每一块乐高积木。

**为什么需要？**
- 在部署到机器人**之前**就能发现bug（比赛时省时间！）
- 不需要物理机器人就能验证数学是否正确
- 放心改代码 — 如果测试仍然通过，说明没有破坏任何东西

**示例：** 测试PID控制器在 Kp=2、误差=5 时输出10：
```
输入：目标值=10，当前值=5 → 误差=5
期望：输出 = Kp × 误差 = 2 × 5 = 10  ✓
```

---

## 2. 我们的测试方法

VEX 机器人运行在 ARM 处理器上，但测试运行在你的**笔记本/台式电脑**上（x86/ARM Mac）。这叫**主机端测试**。

```
┌─────────────────┐          ┌─────────────────┐
│   你的电脑       │          │   VEX V5 主控    │
│  （主机测试）     │          │   （真实机器人）   │
│                 │          │                  │
│  test/          │          │  同样的算法代码    │
│  host_tests.cpp │          │  但使用真实硬件    │
│                 │          │                  │
│  模拟HAL ←──────┤          ├──→ 真实HAL       │
│  （假电机）      │          │  （真电机）       │
└─────────────────┘          └─────────────────┘
```

**要点：** 算法代码（PID、运动规划、里程计）在两个环境中完全一样。只有 HAL 不同 — 测试用**模拟（假）函数**，机器人用**真实硬件函数**。

### 文件结构

所有测试在一个文件中：`test/host_tests.cpp`

```
test/host_tests.cpp
├── 最小测试框架（断言宏）
├── 模拟HAL层（假硬件函数）
├── #include 被测源文件
├── PID控制器测试（6个）
├── PID增强测试（6个） — 抗饱和、D滤波、输出钳位
├── 运动规划测试（5个）
├── 里程计测试（7个）
└── main() — 运行所有测试
```

---

## 3. 如何运行测试

在项目目录下打开终端，运行：

```bash
make test
```

**预期输出（全部通过）：**
```
============================================
  VEX Robot Host-Side Unit Tests
============================================

[PID Controller]
  [RUN ] PID_PositiveErrorProducesPositiveOutput
  [ OK ] PID_PositiveErrorProducesPositiveOutput
  ...（更多测试）

[PID Enhancements]
  ...（6个测试）

[Motion Profile]
  ...（更多测试）

[Odometry]
  ...（更多测试）

============================================
  Results: 24 passed, 0 failed, 24 total
============================================
  ALL TESTS PASSED
```

**如果测试失败：**
```
  [FAIL] PID_PositiveError (line 142): expected 10.000000, got 5.000000 (tol=0.010000)
```
它会告诉你：哪个测试、测试文件的哪一行、期望值 vs. 实际值。

---

## 4. 测试框架详解

我们使用最小化的自定义框架（无外部依赖）。以下是关键宏：

### 定义测试

```cpp
TEST(我的测试名) {
    // 你的测试代码
    ASSERT_NEAR(实际值, 期望值, 容差);
}
```

### 断言宏

| 宏 | 检查内容 | 示例 |
|----|---------|------|
| `ASSERT_TRUE(条件)` | 条件为真 | `ASSERT_TRUE(x > 0)` |
| `ASSERT_NEAR(a, e, t)` | \|a - e\| ≤ t | `ASSERT_NEAR(output, 10.0, 0.01)` |
| `ASSERT_GT(a, b)` | a > b | `ASSERT_GT(speed, 0.0)` |
| `ASSERT_LT(a, b)` | a < b | `ASSERT_LT(error, 1.0)` |

### 运行测试

```cpp
// 在 main() 中：
RUN_TEST(我的测试名);
```

---

## 5. 模拟硬件层

因为测试运行在你的电脑上（不是机器人上），我们需要**假的**硬件函数。这些叫"模拟（Mock）"。

```cpp
// 真实HAL（在机器人上）：               模拟HAL（在测试中）：
double get_left_encoder_ticks() {      double get_left_encoder_ticks() {
  return LeftMotor.position(deg);        return mock_left_ticks;  // ← 我们控制这个值！
}                                      }
```

**模拟变量**让我们可以模拟任何传感器读数：

```cpp
static double mock_left_ticks = 0.0;    // 模拟左编码器
static double mock_right_ticks = 0.0;   // 模拟右编码器
static double mock_imu_heading_rad = 0; // 模拟IMU朝向
static double mock_time_sec = 0.0;      // 模拟时钟
```

每个测试之前，调用 `reset_all_mocks()` 来重置所有模拟值。

---

## 6. PID控制器测试

### 测试 1：正误差→正输出

| 项目 | 值 |
|------|-----|
| **测试内容** | 纯P控制器对正误差的响应 |
| **设置** | Kp=2.0, Ki=0, Kd=0, 目标值=10, 当前值=5 |
| **期望** | 输出 = 2.0 × 5.0 = 10.0 |
| **重要性** | 基本检查 — 如果失败，PID从根本上就是坏的 |

### 测试 2：负误差→负输出

| 项目 | 值 |
|------|-----|
| **测试内容** | 当前值 > 目标值时输出为负 |
| **设置** | Kp=2.0, 目标值=5, 当前值=10 → 误差=-5 |
| **期望** | 输出 = -10.0 |
| **重要性** | 确保修正方向正确 |

### 测试 3：零误差→零输出

| 项目 | 值 |
|------|-----|
| **测试内容** | 已到达目标时不修正 |
| **设置** | 目标值 = 当前值 = 5.0 |
| **期望** | 输出 ≈ 0.0 |
| **重要性** | 机器人到达目标后应该停止 |

### 测试 4：积分累积

| 项目 | 值 |
|------|-----|
| **测试内容** | 持续误差下积分项随时间增长 |
| **设置** | Ki=1.0（纯I），同样误差的两次迭代 |
| **期望** | 第二次输出 > 第一次输出（积分增长了） |
| **重要性** | 积分项用于消除稳态误差 |

### 测试 5：微分响应变化

| 项目 | 值 |
|------|-----|
| **测试内容** | D项对误差变化有反应，误差稳定时为零 |
| **设置** | Kd=1.0（纯D），第一次：误差从0跳到5，第二次：保持5 |
| **期望** | 第一次：较大正输出；第二次：≈ 0 |
| **重要性** | 微分项通过响应变化率来抑制超调 |

### 测试 6：重置清除状态

| 项目 | 值 |
|------|-----|
| **测试内容** | `reset()` 将PID恢复到初始状态 |
| **设置** | 运行10次迭代（累积积分），重置，与新PID比较 |
| **期望** | 重置后的输出 ≈ 全新PID的输出 |
| **重要性** | 在自主运动之间必须重置，避免残留积分 |

---

## 6b. PID增强测试

### 测试 7：抗饱和钳位积分（正向）

| 项目 | 值 |
|------|-----|
| **测试内容** | `set_integral_limit(2.0)` 防止积分超过±2.0 |
| **设置** | Ki=1.0，100次迭代，误差=100，积分限制=2.0 |
| **期望** | 输出 ≈ 2.0（而非无钳位的100+） |
| **重要性** | 防止电机饱和时积分爆炸（如推力对抗） |

### 测试 8：抗饱和钳位积分（负向）

| 项目 | 值 |
|------|-----|
| **测试内容** | 抗饱和对负误差同样对称工作 |
| **设置** | 与测试7相同但使用负误差 |
| **期望** | 输出 ≈ -2.0 |
| **重要性** | 确保钳位在两个方向都有效 |

### 测试 9：D滤波平滑微分

| 项目 | 值 |
|------|-----|
| **测试内容** | `set_d_filter(0.7)` 衰减微分尖峰 |
| **设置** | 两个纯D的PID — 一个原始，一个带EMA滤波 alpha=0.7 |
| **期望** | 第一次误差尖峰时滤波后输出 < 原始输出 |
| **重要性** | 减少噪声引起的电机指令报动 |

### 测试 10：输出限制钳位输出

| 项目 | 值 |
|------|-----|
| **测试内容** | `set_output_limit(5.0)` 将输出钳位到±5.0 |
| **设置** | Kp=10.0，误差=100，输出限制=5.0 |
| **期望** | 输出 = +5.0（而非1000）。负误差 → -5.0 |
| **重要性** | 防止命令超过硬件能力 |

### 测试 11：禁用时不钳位

| 项目 | 值 |
|------|-----|
| **测试内容** | 默认 output_limit=0 意味着不钳位 |
| **设置** | Kp=10.0，误差=100，未调用 set_output_limit() |
| **期望** | 输出 = 1000.0（未钳位） |
| **重要性** | 确保向后兼容 — 默认行为是不钳位 |

### 测试 12：重置清除增强状态

| 项目 | 值 |
|------|-----|
| **测试内容** | `reset()` 同时清除EMA滤波微分状态 |
| **设置** | 启用所有增强的PID，20次迭代，重置，与相同设置的新PID比较 |
| **期望** | 重置后输出 ≈ 同样设置的全新PID输出 |
| **重要性** | 确保没有残留滤波状态带入下一次自主运动 |

---

## 7. 运动规划测试

### 测试 1：加速阶段

| 项目 | 值 |
|------|-----|
| **测试内容** | 运动初期，速度跟随加速曲线 |
| **设置** | 最大速度=1.0, 最大加速度=2.0, t=0.1秒, d=2.0米 |
| **期望** | v = a×t = 2.0×0.1 = 0.2 米/秒 |
| **重要性** | 机器人必须缓慢启动，不能直接跳到全速 |

### 测试 2：达到最大速度

| 项目 | 值 |
|------|-----|
| **测试内容** | 足够时间后速度限制在最大值 |
| **设置** | 最大速度=1.0, t=1.0秒（加速度会给出2.0） |
| **期望** | v = 1.0（被限制） |
| **重要性** | 安全 — 永远不超过配置的速度上限 |

### 测试 3：减速阶段

| 项目 | 值 |
|------|-----|
| **测试内容** | 接近目标时减速 |
| **设置** | 剩余距离 = 0.1米 |
| **期望** | v = √(2×2.0×0.1) ≈ 0.632 < 最大速度 |
| **重要性** | 机器人必须在目标处停下，不能冲过头 |

### 测试 4：零距离→零速度

| 项目 | 值 |
|------|-----|
| **测试内容** | 在目标处：速度应为零 |
| **设置** | 剩余距离 = 0 |
| **期望** | v = 0.0 |
| **重要性** | 到达后机器人应停止 |

### 测试 5：速度永不超过最大值

| 项目 | 值 |
|------|-----|
| **测试内容** | 任何时间/距离组合都不会产生超过最大值的速度 |
| **设置** | 50×50 = 2500种时间和距离的组合 |
| **期望** | 所有 v ≤ 1.0 |
| **重要性** | 确保最大速度上限在所有场景下都有效 |

---

## 8. 里程计测试

### 测试 1：初始位姿为零

| 项目 | 值 |
|------|-----|
| **测试内容** | `set_pose({0,0,0})` 后，读回 (0,0,0) |
| **期望** | x=0, y=0, θ=0 |
| **重要性** | 基本初始化检查 |

### 测试 2：设置位姿有效

| 项目 | 值 |
|------|-----|
| **测试内容** | `set_pose({1.5, 2.5, 0.5})` 正确存储 |
| **期望** | get_pose() 返回 (1.5, 2.5, 0.5) |
| **重要性** | 必须能设置起始位置 |

### 测试 3：直线前进

| 项目 | 值 |
|------|-----|
| **测试内容** | 两轮各前进1米，朝向=0 |
| **设置** | 左脉冲 = 右脉冲 = 1米对应值，IMU朝向 = 0 |
| **期望** | x ≈ 1.0, y ≈ 0.0, θ ≈ 0.0 |
| **重要性** | 核心里程计：直线行驶必须正确 |

### 测试 4：原地转90°

| 项目 | 值 |
|------|-----|
| **测试内容** | 原地旋转（左轮后退，右轮前进） |
| **设置** | 左脉冲=负值，右脉冲=正值（90°弧长），IMU=π/2 |
| **期望** | x ≈ 0, y ≈ 0, θ ≈ π/2 |
| **重要性** | 转弯必须更新朝向但不移动位置 |

### 测试 5：后退

| 项目 | 值 |
|------|-----|
| **测试内容** | 负编码器脉冲 = 后退运动 |
| **设置** | 两轮各-0.5米的脉冲，朝向=0 |
| **期望** | x ≈ -0.5, y ≈ 0 |
| **重要性** | 里程计必须正确处理倒车 |

### 测试 6：多次更新累积

| 项目 | 值 |
|------|-----|
| **测试内容** | 两个半米更新等于一个完整的一米 |
| **设置** | 第一步：前进0.5米。第二步：再前进0.5米 |
| **期望** | 最终 x ≈ 1.0 |
| **重要性** | 增量更新必须是可累加的 — 没有状态损坏 |

---

## 9. 如何添加新测试

1. 打开 `test/host_tests.cpp`
2. 使用 `TEST()` 宏添加新测试函数：

```cpp
TEST(新功能_某条件) {
    reset_all_mocks();       // 从干净状态开始
    mock_time_sec = 1.0;     // 设置模拟状态

    // 调用被测函数
    double result = my_function(input);

    // 检查结果
    ASSERT_NEAR(result, expected_value, 0.01);
}
```

3. 在 `main()` 中注册：

```cpp
RUN_TEST(新功能_某条件);
```

4. 运行 `make test` 验证。

**测试命名规范：** `模块名_测试的内容`

示例：
- `PID_ZeroErrorProducesZeroOutput`（PID_零误差产生零输出）
- `MotionProfile_DecelerationPhase`（运动规划_减速阶段）
- `Odometry_DriveStraightForward`（里程计_直线前进）

---

## 10. 故障排查

| 问题 | 解决方案 |
|------|---------|
| `make test` 显示 "Nothing to be done" | 检查 `makefile` 中是否存在 `test` 目标 |
| `g++: command not found` | 安装 Xcode 命令行工具：`xcode-select --install` |
| `fatal error: 'config.h' file not found` | 从项目根目录运行 |
| 测试编译通过但结果不对 | 在每个测试开头加 `reset_all_mocks()` |
| `Undefined symbol: get_imu_rotation_rad` | 在模拟HAL部分添加该模拟函数 |
| 所有测试通过但机器人行为不对 | 测试只验证数学 — PID增益需要在真实硬件上调参 |

---

## 测试覆盖总结

| 模块 | 测试数 | 覆盖范围 |
|------|--------|---------|
| PID控制器 | 6 | P、I、D各项、零误差、重置 |
| PID增强 | 6 | 抗饱和（±）、D滤波、输出钳位（开/关）、重置 |
| 运动规划 | 5 | 加速、巡航、减速、零距离、边界 |
| 里程计 | 7 | 初始化、设置、前进、转弯、后退、累积、航向 |
| **总计** | **24** | **核心算法+增强功能完全覆盖** |

**设计上未测试的：**
- `turn_to_heading` / `drive_to_pose` — 这些是集成级别的（依赖控制循环时序）。在机器人上测试。
- 回旋镞控制器 — 集成级别；通过机器人上的系统测试验证。
- HAL 函数 — 只是 VEX API 的包装；没什么可单元测试的。电机数组和跟踪轮逻辑通过机器人上的组件测试来验证（见[完整测试文档](3_full_test_doc.md)）。
- `main.cpp` — 竞赛回调函数和电机声明是硬件相关的；通过运行机器人来测试。
- 视觉定位器 — 需要真实的 AprilTag 检测；通过机器人上的集成测试来验证。
