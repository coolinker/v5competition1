# 设计文档 — VEX V5 机器人软件架构

---

## 目录

1. [概述](#1-概述)
2. [系统架构](#2-系统架构)
3. [机器人硬件配置](#3-机器人硬件配置)
4. [逐层设计](#4-逐层设计)
   - 4.1 [配置层](#41-配置层)
   - 4.2 [硬件抽象层（HAL）](#42-硬件抽象层hal)
   - 4.3 [定位层 — 里程计](#43-定位层--里程计)
   - 4.4 [控制层 — PID 与运动规划](#44-控制层--pid-与运动规划)
   - 4.5 [运动层 — 高层指令](#45-运动层--高层指令)
   - 4.6 [主程序入口](#46-主程序入口)
5. [数据流](#5-数据流)
6. [核心算法](#6-核心算法)
7. [架构优势](#7-架构优势)
8. [未来路线图](#8-未来路线图)

---

## 1. 概述

本项目是为 VEX V5 竞赛机器人设计的模块化软件架构。设计目标：

- **容易理解** — 每个文件只负责一件事
- **可扩展** — 随时可以升级功能
- **竞赛就绪** — 配备高精度追踪轮定位 + 视觉校正

软件提供：

1. **位置追踪**（里程计）— "我在场地上的哪里？"（垂直双追踪轮 + IMU）
2. **视觉定位校正** — AI Vision 检测 AprilTag 标签修正累积误差
3. **PID 控制** — "怎样平稳地到达目标？"
4. **运动规划** — "怎样平滑地加速和减速？"
5. **自主运动** — "开到这个点" 或 "转到这个朝向"

---

## 2. 系统架构

软件按**分层**组织，像一摞积木。上层使用下层，但下层绝不依赖上层。

```
┌─────────────────────────────────────────────┐
│              main.cpp                       │  ← 应用层（最顶层）
│          （竞赛回调函数）                      │
├─────────────────────────────────────────────┤
│     motion/                                 │  ← 运动指令层
│   turn_to_heading    drive_to_pose          │     "转90°"、"开到(1,0)"
├─────────────────────────────────────────────┤
│     control/                                │  ← 算法层
│   PIDController      MotionProfile          │     PID数学、速度规划
├─────────────────────────────────────────────┤
│     localization/                           │  ← 状态估计层
│   odometry (Pose: x, y, θ)                 │     "我在哪？"（追踪轮 + IMU）
│   vision_localizer (AprilTag → 绝对位置)     │     视觉校正
├─────────────────────────────────────────────┤
│     hal/                                    │  ← 硬件抽象层
│   motors  imu  time  tracking_wheels        │     与真实硬件通信
│   vision  hal_log                           │
├─────────────────────────────────────────────┤
│     config.h                                │  ← 常量配置
│   （端口、尺寸、PID增益、追踪轮偏移量）        │     唯一的参数来源
└─────────────────────────────────────────────┘
```

**为什么分层？**

- 可以在**没有硬件**的情况下测试上层逻辑（用模拟HAL）
- 可以只改 HAL 就**更换硬件**（换电机、传感器）
- 每一层可以独立开发和调试

---

## 3. 机器人硬件配置

本项目为 **6电机差速底盘** + **垂直双追踪轮** + **IMU** + **AI Vision** 设计。

### 硬件清单

| 设备 | 数量 | 端口 | 备注 |
|------|------|------|------|
| V5 电机（蓝色 600RPM） | 6 | Port 1-6 | 左3 + 右3 |
| V5 惯性传感器 (IMU) | 1 | Port 10 | 水平安装在底盘中心 |
| V5 旋转传感器（纵向追踪轮） | 1 | Port 8 | 2.75" 全向轮，平行于前进方向 |
| V5 旋转传感器（横向追踪轮） | 1 | Port 9 | 2.75" 全向轮，垂直于前进方向 |
| V5 AI Vision 传感器 | 1 | Port 12 | 朝前安装 |

### 接线图

```
  Port 1 [左前电机]  ──────  [右前电机] Port 4
  Port 2 [左中电机]  ──────  [右中电机] Port 5
  Port 3 [左后电机]  ──────  [右后电机] Port 6

  Port 10 = IMU（惯性传感器）
  Port 8  = 纵向追踪轮（旋转传感器）
  Port 9  = 横向追踪轮（旋转传感器）
  Port 12 = AI Vision（视觉传感器）
```

### 追踪轮布局（垂直双轮方案）

```
         ↑ 前进方向
         |
  [纵向轮(↑)]     ← 测量前后位移
         |
——[横向轮(→)]——   ← 测量左右侧滑
         |
```

两个追踪轮呈十字形安装。旋转角度完全由 IMU 提供。
这种方案比平行双轮更好，因为**能检测侧向滑动**（被对手撞歪时也能准确追踪）。

---

## 4. 逐层设计

### 4.1 配置层

**文件：** `include/config.h`

一个头文件，包含所有可调参数。所有数值集中在此，便于比赛现场快速调参。

**参数分组：**

| 组别 | 关键常量 | 说明 |
|------|---------|------|
| 1. 物理参数 | `WHEEL_DIAMETER`（0.08255 m）、`WHEEL_TRACK`（0.33 m）、`TICKS_PER_REV`（300） | 驱动轮尺寸 |
| 2. 电机端口 | `LEFT_FRONT_MOTOR_PORT` … `RIGHT_REAR_MOTOR_PORT`、`MOTORS_PER_SIDE`（3） | 6 电机分配 |
| 3. IMU | `IMU_PORT`（10）、`IMU_FUSION_ALPHA`（0.98，预留） | 惯性传感器 |
| 4. 追踪轮 | `FORWARD/LATERAL_TRACKING_PORT`、`TRACKING_WHEEL_DIAMETER`（0.06985 m）、`FORWARD/LATERAL_WHEEL_OFFSET` | 垂直双轮方案 |
| 5. 转弯 PID | `TURN_KP`（3.5）/ `KI`（0.02）/ `KD`（0.25）、抗饱和、D滤波 | 原地转弯 |
| 6. 直线参数 | `DRIVE_KP`（8.0）/ `KI`（0.05）/ `KD`（0.5）、容差、超时 | 行驶控制 |
| 7. 运动规划 | `MAX_VELOCITY`（1.2 m/s）、`MAX_ACCELERATION`（3.0 m/s²）、`BOOMERANG_LEAD`（0.6） | 速度曲线 + 回旋镞 |
| 8. 循环间隔 | `LOOP_INTERVAL_MS`（10） | 100Hz |
| 9. 日志 | `LOG_VERBOSITY`（2） | 调试输出级别 |
| 10. 视觉 | `VISION_PORT`（11）、焦距、标签尺寸、置信度阈值、修正强度 | AprilTag 定位 |

**为什么放在一个文件？** 在比赛现场调参时，只需要去一个地方改数字，不用翻遍10个文件。

---

### 4.2 硬件抽象层（HAL）

**文件：**
- `include/hal/motors.h` + `src/hal/motors.cpp` — 电机控制
- `include/hal/imu.h` + `src/hal/imu.cpp` — 惯性传感器
- `include/hal/time.h` + `src/hal/time.cpp` — 时间函数
- `include/hal/tracking_wheels.h` + `src/hal/tracking_wheels.cpp` — 追踪轮传感器
- `include/hal/vision.h` + `src/hal/vision.cpp` — AI Vision 传感器
- `include/hal/hal_log.h` + `src/hal/hal_log.cpp` — 日志系统

HAL是对VEX硬件的薄封装。它提供简单函数，隐藏VEX特定的API：

```
VEX API（复杂）                HAL（简单）
──────────────                 ────────────
motor.spin(fwd, 8, volt)  →   set_drive_motors(8.0, 8.0)
motor.stop(brake)          →   stop_drive_motors()
inertial.heading(degrees)  →   get_imu_heading_rad()
rotation.position(degrees) →   tracking_get_forward_distance_m()
```

**核心函数：**

| 模块 | 函数 | 功能 |
|------|------|------|
| motors | `set_drive_motors(left_v, right_v)` | 设置左/右电机电压（-12到+12） |
| motors | `stop_drive_motors()` | 刹车停止所有电机 |
| motors | `get_left_encoder_ticks()` | 读取左轮编码器 |
| motors | `get_right_encoder_ticks()` | 读取右轮编码器 |
| motors | `reset_encoders()` | 编码器归零 |
| imu | `get_imu_heading_rad()` | 当前朝向（弧度）[0, 2π) |
| imu | `get_imu_rotation_rad()` | 无界旋转角度（可超过2π） |
| imu | `calibrate_imu()` | 校准IMU并等待完成 |
| imu | `reset_imu()` | 朝向归零 |
| tracking | `tracking_get_forward_distance_m()` | 纵向追踪轮累计距离（米） |
| tracking | `tracking_get_lateral_distance_m()` | 横向追踪轮累计距离（米） |
| tracking | `tracking_wheels_reset()` | 追踪轮读数归零 |
| tracking | `tracking_wheels_connected()` | 检查追踪轮是否已连接 |
| time | `get_time_sec()` / `get_time_ms()` | 当前时间 |
| time | `wait_ms(ms)` | 休眠若干毫秒 |
| vision | `vision_detect_apriltags()` | 检测 AprilTag 标签 |
| log | `hal_log(msg)` | 输出日志到终端和 SD 卡 |

**设计决策：**
- 电机电压在HAL内部被限制在 [-12, +12]，上层代码不需要担心超出硬件极限
- `set_drive_motors()` 将相同电压发送到一侧的所有 3 个电机（调用者无需知道电机数量）
- 追踪轮函数将旋转传感器的角度自动转换为米（使用 `TRACKING_WHEEL_CIRCUMFERENCE`）

---

### 4.3 定位层 — 里程计

**文件：** `include/localization/odometry.h` + `src/localization/odometry.cpp`

里程计回答这个问题：**"我的机器人在场地上的哪里？"**

它追踪机器人的**位姿（Pose）**——位置和朝向的组合：

```
Pose = { x, y, θ }
         ↑  ↑  ↑
         │  │  └── 朝向角度（弧度，0 = 面向右/+X方向）
         │  └───── Y 位置（米，向左为正）
         └──────── X 位置（米，向前为正）
```

**工作原理（垂直双轮方案，逐步说明）：**

1. **读取传感器** — 获取纵向轮、横向轮的距离和 IMU 的旋转角度
2. **计算增量** — 减去上次读数，得到自上次更新以来的变化：
   - `Δforward`（纵向轮走了多远）
   - `Δlateral`（横向轮滑了多远）
   - `Δθ`（IMU 测到转了多少，**100% 来自 IMU**）
3. **补偿旋转弧线** — 偏离旋转中心的追踪轮在旋转时会画弧，不是真正的平移：
   - `Δforward_corrected = Δforward - FORWARD_WHEEL_OFFSET × Δθ`
   - `Δlateral_corrected = Δlateral - LATERAL_WHEEL_OFFSET × Δθ`
4. **转换到全局坐标**，使用中点近似法：
   - `mid_θ = θ + Δθ/2`
   - `x += Δforward × cos(mid_θ) - Δlateral × sin(mid_θ)`
   - `y += Δforward × sin(mid_θ) + Δlateral × cos(mid_θ)`
   - `θ += Δθ`

**为什么用追踪轮而不是驱动轮编码器？** 驱动轮在加速、转弯、被推时会打滑，编码器读数不准。追踪轮没有动力、不会打滑，测量更精确。

**为什么角度 100% 来自 IMU？** 垂直双轮方案只有一个前后轮和一个左右轮，无法像平行双轮那样通过两轮差值计算旋转角度。IMU 短期内非常精确，是旋转的最佳来源。

#### 视觉定位 — AI Vision Sensor 绝对位置校正

**文件：**
- `include/hal/vision.h` + `src/hal/vision.cpp`
- `include/localization/vision_localizer.h` + `src/localization/vision_localizer.cpp`

视觉定位系统使用 **V5 AI Vision Sensor** 检测场地上已知位置的 **AprilTag** 标签，提供**绝对位置校正**，配合追踪轮的相对定位，实现高精度定位。

**追踪轮 vs AI Vision（各有优势，本项目两者都用）**

| | 追踪轮 | AI Vision |
|---|---|---|
| 定位类型 | 相对定位（积累漂移） | **绝对定位（重置漂移）** |
| 更新频率 | 100 Hz（非常快） | 20 Hz（较慢） |
| 精度来源 | 轮与地面接触质量 | 标签可见性 + 距离 |
| 抗碰撞性 | 碰撞可能使轮偏移 | **无物理对准需求** |

**工作原理：**

```
场地上的 AprilTag（已知位置）
        │
        ▼
   ┌────────────────┐
   │  AI Vision     │  ← 检测标签 → 像素坐标 + 大小
   │  Sensor (HAL)  │
   └────────────────┘
        │
        ▼
   ┌────────────────┐
   │  Vision        │  ← 针孔相机模型 → 距离 + 方位角
   │  Localizer     │  ← 已知标签位置 → 机器人绝对坐标
   └────────────────┘
        │
        ▼
   互补滤波融合到里程计
   pose = (1-α) × odom + α×confidence × vision
```

**逐步算法：**

1. **拍摄快照** — AI Vision Sensor 检测视野内的 AprilTags
2. **距离估算** — 用针孔相机模型：`距离 = (标签实际尺寸 × 焦距) / 像素大小`
3. **方位角估算** — 从标签在图像中的水平位置：`方位角 = atan(像素偏移 / 焦距)`
4. **坐标变换** — 已知标签场地坐标 + 距离 + 方位角 → 机器人场地坐标
5. **置信度评分** — 基于距离和标签大小：近距离大标签 → 高置信度
6. **互补滤波融合** — 按置信度加权混合到里程计估计中

**安全机制：**
- 置信度低于 `VISION_MIN_CONFIDENCE` 的检测被丢弃
- 校正距离超过 `VISION_MAX_CORRECTION_M`（30cm）的被拒绝（可能是误检）
- 朝向始终来自 IMU（比视觉更可靠）
- 使用 `set_pose_no_reset()` 微调位姿，不破坏编码器增量跟踪

**场地标签布局示例（12ft × 12ft 场地）：**

```
  ┌───────────────────────────────────┐
  │              +y 墙               │
  │  Tag7                      Tag8  │
  │                                  │
  │  Tag3                      Tag4  │
  │ +x墙                      -x墙  │
  │  Tag1                      Tag2  │
  │                                  │
  │  Tag5                      Tag6  │
  │              -y 墙               │
  └───────────────────────────────────┘
     原点 (0, 0) = 左下角
```

---

### 4.4 控制层 — PID 与运动规划

**文件：**
- `include/control/pid.h` + `src/control/pid.cpp`
- `include/control/motion_profile.h` + `src/control/motion_profile.cpp`

#### PID 控制器

PID控制器就像一个智能恒温器，持续调整输出以达到目标：

```
误差 = 目标值 - 当前值

输出 = Kp × 误差              ← 比例项："我偏了多远？"
     + Ki × ∫误差 × dt        ← 积分项："我已经偏了多久？"
     + Kd × d误差/dt          ← 微分项："我在接近还是远离？"
```

**类比：** 想象你开车驶向红绿灯：
- **P**（比例）：离得越远，油门踩得越狠 → 可能会冲过头
- **I**（积分）：如果长期偏离，就加大力度 → 消除持续偏差
- **D**（微分）：如果接近得太快，开始刹车 → 减少超调

**增强功能：**

| 增强功能 | 方法 | 作用 |
|---------|------|------|
| **抗饱和** | `set_integral_limit(limit)` | 将积分项钳位到 ±limit，防止电机饱和时积分爆炸（如推力对抗时） |
| **微分EMA滤波** | `set_d_filter(alpha)` | 低通滤波：`filtered = α×prev + (1-α)×raw`。平滑微分噪声尖峰。alpha=0禁用 |
| **输出钳位** | `set_output_limit(limit)` | 对称 ±limit 输出钳位。防止命令超过硬件能力 |

运动代码在 `reset()` 后调用设置器激活竞赛级行为（转弯 PID 使用抗饱和 3.0、D滤波 0.5、输出钳位 12V）。

---

#### 运动规划

与其从0瞬间跳到最高速度（会导致轮子打滑和运动生硬），我们使用**梯形速度规划**：

```
速度
▲
│    ┌────────────┐
│   /              \
│  /                \
│ /                  \
└──────────────────────── 时间
  加速     巡航    减速
```

每一刻，目标速度 = min(加速限制, 最高速度, 减速限制)：

1. **加速限制**：`v = a × t` — 不能加速太快
2. **最高速度上限**：`v = v_max` — 不能超过极速
3. **减速限制**：`v = √(2 × a × d)` — 必须能及时停下来

三个约束中最小的那个获胜。

---

### 4.5 运动层 — 高层指令

**文件：**
- `include/motion/turn_to_heading.h` + `src/motion/turn_to_heading.cpp`
- `include/motion/drive_to_pose.h` + `src/motion/drive_to_pose.cpp`

#### 原地转向（turn_to_heading）

让机器人原地旋转到指定方向。使用PID控制朝向误差。

**算法：**
1. 计算朝向误差 = 目标 − 当前
2. 归一化到 [-π, +π]（总是走近路）
3. PID → 角速度 → 差速轮电压
4. 当误差在 `TURN_SETTLE_TIME_MS` 内保持很小时退出，或超时退出

转向PID激活抗饱和（`TURN_INTEGRAL_LIMIT`）、微分滤波（`TURN_D_FILTER`）和输出钳位（12V），在高扭力底盘上实现更平滑精确的转向。

**退出条件（为什么需要两个？）：**
- **稳定时间**：确保机器人真的停了，不是只是路过目标值
- **超时**：安全网 — 如果出了问题，不要永远转下去

---

#### 驶向目标点（drive_to_pose）— 回旋镞控制器

驱动机器人到场地上的指定 (x, y, θ) 位姿。使用**回旋镞（Boomerang）控制器**实现平滑弧线接近。

不停下来转向，而是在目标点沿其朝向向量后方放置一个"胡萝卜"引导点。机器人瞬准胡萝卜；随着距离缩小，胡萝卜收敛到目标，产生平滑曲线接近，到达时朝向正确。

```
         胡萝卜 ◀── lead ──── 目标
           ╱                     ↑ θ_最终
        机器人
```

**回旋镞特性：**
- 平滑曲线接近 — 无中间停顿
- 最终朝向控制 — 到达时面向期望方向
- 支持倒车（`reverse=true` 参数）
- 余弦扩流 — 朝向误差大时减速
- 加速度撑流率限制 — 防止轮子打滑
- 完整角度PID，带抗饱和、D滤波和输出钳位

---

### 4.6 主程序入口

**文件：** `src/main.cpp`

入口程序将所有东西粘合在一起：

- **硬件声明**：
  - 6 个驱动电机 → `LeftFront/Mid/Rear`、`RightFront/Mid/Rear`（蓝色齿轮盒，左侧反转）
  - IMU → `DrivetrainInertial`
  - 追踪轮 → `ForwardTrackingSensor`、`LateralTrackingSensor`
  - AI Vision → `VisionSensor`
- **后台任务**：屏幕显示、日志记录
- **竞赛回调**：`pre_auton()`、`autonomous()`、`usercontrol()`

注意：左侧电机的 `reverse` 标志考虑了物理安装方向 — 左侧电机与右侧电机面向相反。

---

## 5. 数据流

以下是自主模式中数据在系统中的流动方式：

```
追踪轮 + IMU                  AI Vision Sensor
      │                              │
      ▼                              ▼
  ┌────────────┐            ┌──────────────────┐
  │   里程计    │──→ 位姿 ←──│  Vision          │
  │ (100 Hz)   │   {x,y,θ}  │  Localizer       │
  └────────────┘      │      │  (20 Hz, 绝对)   │
                      │      └──────────────────┘
                      │        互补滤波融合 ↑
                      ▼
              ┌──────────────────┐
              │   drive_to_pose  │
              │   或              │
              │  turn_to_heading │
              └──────────────────┘
                    │         │
          ┌─────────┘         └──────────┐
          ▼                              ▼
   ┌──────────────┐              ┌──────────────┐
   │  运动规划     │              │     PID      │
   │（目标速度）    │              │（修正值）     │
   └──────────────┘              └──────────────┘
          │                              │
          └──────────┬───────────────────┘
                     ▼
              ┌──────────────┐
              │  HAL 电机    │──→ 轮子电压
              └──────────────┘
```

---

## 6. 核心算法

### 角度归一化

计算两个角度的差值时，结果必须在 [-π, +π] 范围内，以确保机器人总是走最短路线：

```cpp
error = atan2(sin(error), cos(error));
```

没有这个处理，从350°转到10°会走远路（转340°）而不是近路（转20°）。

---

### 垂直双轮里程计

与传统差速里程计（用左右轮差值算旋转）不同，垂直双轮方案直接测量两个独立轴向的位移：

```
输入：
  Δfwd  = 纵向轮位移增量
  Δlat  = 横向轮位移增量
  Δθ    = IMU 旋转增量

补偿旋转弧线（偏离旋转中心的轮子画弧）：
  Δfwd_c = Δfwd - FORWARD_WHEEL_OFFSET × Δθ
  Δlat_c = Δlat - LATERAL_WHEEL_OFFSET × Δθ

全局坐标更新（中点近似法）：
  mid_θ = θ + Δθ/2
  x += Δfwd_c × cos(mid_θ) - Δlat_c × sin(mid_θ)
  y += Δfwd_c × sin(mid_θ) + Δlat_c × cos(mid_θ)
  θ += Δθ
```

---

### 差速驱动运动学

轮速与机器人运动之间的转换：

```
正向：                       逆向：
v = (v右 + v左) / 2          v左 = v - ω × W/2
ω = (v右 - v左) / W          v右 = v + ω × W/2

其中：
  v   = 线速度（米/秒）
  ω   = 角速度（弧度/秒）
  W   = 轮距（米）
  v左  = 左轮速度
  v右  = 右轮速度
```

---

## 7. 架构优势

### 模块化（每个文件一个职责）
- HAL 封装硬件细节 — 更换传感器只需改 HAL，上层代码不变
- PID 和运动规划是通用算法 — 不依赖任何具体机器人配置
- 里程计只关心"位姿在哪"，不关心"谁在读传感器"

### 可测试性（脱离硬件测试）
- 24 个主机端单元测试，覆盖 PID、运动曲线、里程计
- Mock HAL 模拟所有传感器 — 测试在电脑上 0.1 秒跑完
- 每次改代码后立即 `make test` 验证

### 关注点分离
```
  什么变了              在哪里              什么没变
  ─────────────        ──────────────      ───────────────────
  电机端口         →   config.h            PID算法
  轮子尺寸         →   config.h            里程计数学
  PID增益          →   config.h            运动规划
  追踪轮偏移量     →   config.h            驶向目标点逻辑
  传感器类型       →   hal/*.cpp           转向指定朝向逻辑
```

### 易于扩展
- 添加子系统（吸取器、投石器、气动）遵循相同的 HAL 模式
- 添加新的定位源（如 GPS）只需实现新的定位模块并融合到里程计

---

## 8. 未来路线图

| 优先级 | 功能 | 难度 | 状态 |
|--------|------|------|------|
| 1 | **在真实机器人上调PID** | 简单 | 持续进行 |
| 2 | **添加机构**（吸取器、升降、夹持） | 简单 | 下一步 |
| ~~3~~ | ~~**PID抗饱和**~~ | ~~中等~~ | ✅ 已完成 — `set_integral_limit()` |
| ~~3b~~ | ~~**PID微分滤波**~~ | ~~简单~~ | ✅ 已完成 — `set_d_filter()` |
| ~~3c~~ | ~~**PID输出钳位**~~ | ~~简单~~ | ✅ 已完成 — `set_output_limit()` |
| ~~4~~ | ~~**IMU朝向绕回修复**~~ | ~~中等~~ | ✅ 已完成 — 增量IMU（delta-based） |
| ~~5~~ | ~~**曲线路径跟随**~~ | ~~困难~~ | ✅ 已完成 — 回旋镞控制器 |
| ~~6~~ | ~~**追踪轮定位**~~ | ~~中等~~ | ✅ 已完成 — 垂直双轮方案（纵向+横向） |
| ~~7~~ | ~~**绝对位置定位**~~ | ~~困难~~ | ✅ 已完成 — AI Vision AprilTag 定位 |
| 8 | **S曲线运动规划** | 中等 | 未来 — 限制加加速度 |
| 9 | **多标签三角定位** | 中等 | 未来 — 多标签同时检测提升精度 |
| 10 | **视觉朝向校正** | 中等 | 未来 — 从标签角度估算heading |
| 11 | **卡尔曼滤波器**定位 | 困难 | 未来 — 最优多传感器融合 |

---

## 文件地图

```
v5competition1/
├── include/
│   ├── config.h                    ← 所有可调参数
│   ├── vex.h                       ← VEX SDK头文件
│   ├── hal/
│   │   ├── motors.h                ← 电机函数
│   │   ├── imu.h                   ← IMU函数
│   │   ├── time.h                  ← 时间函数
│   │   ├── tracking_wheels.h       ← 追踪轮函数
│   │   ├── vision.h                ← AI Vision传感器函数
│   │   └── hal_log.h               ← 日志系统
│   ├── localization/
│   │   ├── odometry.h              ← 位置追踪（追踪轮 + IMU）
│   │   └── vision_localizer.h      ← 视觉绝对定位
│   ├── control/
│   │   ├── pid.h                   ← PID控制器
│   │   └── motion_profile.h        ← 速度规划
│   └── motion/
│       ├── turn_to_heading.h       ← 转向指令
│       └── drive_to_pose.h         ← 行驶指令（回旋镞控制器）
├── src/
│   ├── main.cpp                    ← 入口程序
│   ├── hal/     (*.cpp)            ← HAL实现
│   ├── localization/ (*.cpp)       ← 里程计 + 视觉定位实现
│   ├── control/ (*.cpp)            ← 算法实现
│   └── motion/  (*.cpp)            ← 指令实现
├── test/
│   └── host_tests.cpp              ← 主机端单元测试（24个）
└── docs/
    ├── en/                         ← 英文文档
    └── cn/                         ← 中文文档
```
