# 设计文档 — VEX V5 机器人软件架构

---

## 目录

1. [概述](#1-概述)
2. [系统架构](#2-系统架构)
3. [机器人配置](#3-机器人配置)
4. [逐层设计](#4-逐层设计)
   - 4.1 [配置层](#41-配置层)
   - 4.2 [硬件抽象层（HAL）](#42-硬件抽象层hal)
   - 4.3 [定位层 — 里程计](#43-定位层--里程计)
   - 4.4 [控制层 — PID 与运动规划](#44-控制层--pid-与运动规划)
   - 4.5 [运动层 — 高层指令](#45-运动层--高层指令)
   - 4.6 [主程序入口](#46-主程序入口)
5. [数据流](#5-数据流)
6. [核心算法](#6-核心算法)
7. [架构优势展示](#7-架构优势展示)
8. [未来路线图](#8-未来路线图)

---

## 1. 概述

本项目是为 VEX V5 竞赛机器人设计的模块化软件架构。设计目标：

- **上手简单** — 开箱即用，适用于基础差速驱动机器人
- **容易理解** — 每个文件只负责一件事
- **可扩展** — 随时可以升级为顶级竞赛代码库

代码库支持**多种机器人配置** — 从简单的2电机入门机器人到高级的6电机竞赛底盘 — 全部共享相同的控制、定位和运动代码。只需在 `config.h` 中修改一个 `#define` 即可切换配置。

软件提供：

1. **位置追踪**（里程计）— "我在场地上的哪里？"
2. **PID 控制** — "怎样平稳地到达目标？"
3. **运动规划** — "怎样平滑地加速和减速？"
4. **自主运动** — "开到这个点" 或 "转到这个朝向"

---

## 2. 系统架构

软件按**分层**组织，像一摞积木。上层使用下层，但下层绝不依赖上层。

```
┌─────────────────────────────────────────────┐
│              main.cpp                       │  ← 应用层（最顶层）
│          （竞赛回调函数）                      │
├─────────────────────────────────────────────┤
│     motion/                                 │  ← 运动指令层
│   turn_to_heading    drive_to_pose          │     "转90°"、"开到(1,0)"
├─────────────────────────────────────────────┤
│     control/                                │  ← 算法层
│   PIDController      MotionProfile          │     PID数学、速度规划
├─────────────────────────────────────────────┤
│     localization/                           │  ← 状态估计层
│   odometry (Pose: x, y, θ)                 │     "我在哪？"
├─────────────────────────────────────────────┤
│     hal/                                    │  ← 硬件抽象层
│   motors    imu    time                     │     与真实硬件通信
├─────────────────────────────────────────────┤
│     config.h                                │  ← 常量配置
│   （端口、尺寸、PID增益）                      │     唯一的参数来源
└─────────────────────────────────────────────┘
```

**为什么分层？**

- 可以在**没有硬件**的情况下测试上层逻辑（用模拟HAL）
- 可以只改 HAL 就**更换硬件**（换电机、传感器）
- 每一层可以独立开发和调试

---

## 3. 机器人配置

代码库自带两个可直接使用的底盘配置。
在 `config.h` 中取消注释一个 `#define` 即可选择：

| | **ROBOT_2MOTOR**（入门级） | **ROBOT_6MOTOR**（高级） |
|---|---|---|
| **电机数** | 左1 + 右1 | 左3 + 右3 |
| **齿轮盒** | 绿色 18:1（200 RPM） | 蓝色 6:1（600 RPM） |
| **轮子** | 4英寸（0.1016 m） | 3.25英寸（0.08255 m） |
| **最高速度** | 0.8 m/s | 1.2 m/s |
| **加速度** | 1.5 m/s² | 3.0 m/s² |
| **扭矩** | 1× 基准 | 3× 基准 |
| **转弯精度** | ~2° | ~1.4° |
| **适用场景** | 学习、原型 | 竞赛、推力对抗 |

### 配置之间变了什么？

```
  含有配置相关代码的文件：          保持不变的文件：
  ────────────────────────────         ──────────────────────────
  config.h          ← 常量           control/pid.h & .cpp
  motors.cpp        ← HAL实现        control/motion_profile.h & .cpp
  main.cpp          ← 硬件对象       hal/motors.h   ← API不变！
  odometry.cpp      ← 6M增量融合     hal/imu.h & .cpp
  drive_to_pose.cpp ← 6M回旋镞       hal/time.h & .cpp
  turn_to_heading.cpp ← 6M PID增强  localization/odometry.h ← API不变！
                                        motion/drive_to_pose.h
                                        motion/turn_to_heading.h
```

**配置相关代码使用 `#ifdef ROBOT_6MOTOR` 块** — 2电机代码路径在 `#else` 分支中原样保留。所有头文件API保持不变。

### 6电机接线图

```
  端口1 [左前]  ──────  [右前]  端口4
  端口2 [左中]  ──────  [右中]  端口5    ← 编码器源
  端口3 [左后]  ──────  [右后]  端口6
                IMU = 端口10
```

中间电机用于编码器读数 — 它们与地面接触最稳定，受转弯摩擦影响最小。

---

## 4. 逐层设计

### 4.1 配置层

**文件：** `include/config.h`

一个头文件，按机器人配置组织所有可调参数。文件使用编译时 `#ifdef` 守卫来选择配置，如果没有选择或选择了多个，会产生编译错误。

**共享常量**（所有配置相同）：

| 常量 | 含义 |
|------|------|
| `WHEEL_CIRCUMFERENCE` | 派生值：π × 直径（自动计算） |
| `LOOP_INTERVAL_MS` | 控制循环周期（10毫秒） |

**配置专属常量**（每个配置定义自己的值）：

| 常量 | 2电机值 | 6电机值 |
|------|---------|--------|
| `WHEEL_DIAMETER` | 0.1016 m（4"） | 0.08255 m（3.25"） |
| `WHEEL_TRACK` | 0.381 m（15"） | 0.330 m（13"） |
| `TICKS_PER_REV` | 360（绿色） | 300（蓝色） |
| `TURN_KP/KI/KD` | 2.0 / 0.0 / 0.1 | 3.5 / 0.02 / 0.25 |
| `DRIVE_KP/KI/KD` | 5.0 / 0.0 / 0.3 | 8.0 / 0.05 / 0.5 |
| `MAX_VELOCITY` | 0.8 m/s | 1.2 m/s |
| `MAX_ACCELERATION` | 1.5 m/s² | 3.0 m/s² |
| `MOTORS_PER_SIDE` | 1 | 3 |
| `DRIVE_INTEGRAL_LIMIT` | — | 5.0（抗饱和） |
| `DRIVE_D_FILTER` | — | 0.7（微分EMA） |
| `TURN_INTEGRAL_LIMIT` | — | 3.0（抗饱和） |
| `TURN_D_FILTER` | — | 0.5（微分EMA） |
| `BOOMERANG_LEAD` | — | 0.6（回旋镞引导系数） |

**为什么放在一个文件？** 在比赛现场调参时，只需要去一个地方改数字，不用翻遍10个文件。

---

### 4.2 硬件抽象层（HAL）

**文件：**
- `include/hal/motors.h` + `src/hal/motors.cpp`
- `include/hal/imu.h` + `src/hal/imu.cpp`
- `include/hal/time.h` + `src/hal/time.cpp`

HAL是对VEX硬件的薄封装。它提供简单函数，隐藏VEX特定的API：

```
VEX API（复杂）                HAL（简单）
──────────────                 ────────────
motor.spin(fwd, 8, volt)  →   set_drive_motors(8.0, 8.0)
motor.stop(brake)          →   stop_drive_motors()
motor.position(degrees)    →   get_left_encoder_ticks()
inertial.heading(degrees)  →   get_imu_heading_rad()
```

**核心函数：**

| 模块 | 函数 | 功能 |
|------|------|------|
| motors | `set_drive_motors(left_v, right_v)` | 设置左/右电机电压（-12到+12） |
| motors | `stop_drive_motors()` | 刹车停止两个电机 |
| motors | `get_left_encoder_ticks()` | 读取左轮编码器 |
| motors | `get_right_encoder_ticks()` | 读取右轮编码器 |
| motors | `reset_encoders()` | 两个编码器归零 |
| imu | `get_imu_heading_rad()` | 当前朝向（弧度）(0, 2π) |
| imu | `get_imu_rotation_rad()` | 无界旋转角度（可超过2π） |
| imu | `calibrate_imu()` | 校准IMU并等待完成 |
| imu | `reset_imu()` | 朝向归零 |
| time | `get_time_sec()` | 当前时间（秒） |
| time | `get_time_ms()` | 当前时间（毫秒） |
| time | `wait_ms(ms)` | 休眠若干毫秒 |

**设计决策：** 电机电压在HAL内部被限制在[-12, +12]，上层代码不需要担心超出硬件极限。

**多电机透明性：** 在6电机配置中，`set_drive_motors()` 将相同电压发送到一侧的所有3个电机。`get_left_encoder_ticks()` 从指定的主编码器（中间电机）读取数据。API签名完全相同 — 调用者永远不知道有多少个物理电机存在。

---

### 4.3 定位层 — 里程计

**文件：** `include/localization/odometry.h` + `src/localization/odometry.cpp`

里程计回答这个问题：**"我的机器人在场地上的哪里？"**

它追踪机器人的**位姿（Pose）**——位置和朝向的组合：

```
Pose = { x, y, θ }
         ↑  ↑  ↑
         │  │  └── 朝向角度（弧度，0 = 面向右/+X方向）
         │  └───── Y 位置（米，从起点向前）
         └──────── X 位置（米，从起点向右）
```

**工作原理（逐步说明）：**

1. **读取编码器** — 获取左右轮的总脉冲数
2. **计算增量脉冲** — 减去上次读数，得到自上次更新以来的变化
3. **转换为米** — `增量米数 = 增量脉冲 × (轮周长 / 每转脉冲数)`
4. **计算机器人运动：**
   - 线性距离：`d = (d左 + d右) / 2`
   - 编码器推算的朝向变化：`dθ_编码器 = (d右 - d左) / 轮距`
5. **与IMU融合** — 混合编码器朝向和IMU朝向：
   - **2电机**（绝对融合）：`θ = α × θ_IMU + (1-α) × θ_编码器`，其中 α = 0.98
   - **6电机**（增量融合）：`Δθ = α × Δθ_IMU + (1-α) × Δθ_编码器`
     使用 `get_imu_rotation_rad()` 的增量而非绝对值 `heading()`，避免在 0°/360° 边界处产生的灾难性绕回跳变bug。
6. **更新位置**，使用中点近似法：
   - `x += d × cos(θ_中间)`
   - `y += d × sin(θ_中间)`

**为什么要IMU融合？** 编码器在轮子打滑时会漂移。IMU不会打滑，但会随时间缓慢漂移。两者结合可获得最佳精度。

**为什么6电机用增量融合？** 2电机的绝对融合（`α × heading + (1-α) × encoder`）在低速时工作正常，但有一个致命缺陷：当朝向穿越 0°/360°（≈ 0/2π 弧度）时，加权平均会产生无意义的跳变（例如 `0.98 × 0.01 + 0.02 × 6.27 ≈ 0.14` 而非正确的 `≈ 0.01`）。增量融合通过融合朝向*变化量*来完全避免这个问题。

---

### 4.4 控制层 — PID 与运动规划

**文件：**
- `include/control/pid.h` + `src/control/pid.cpp`
- `include/control/motion_profile.h` + `src/control/motion_profile.cpp`

#### PID 控制器

PID控制器就像一个智能恒温器，持续调整输出以达到目标：

```
误差 = 目标值 - 当前值

输出 = Kp × 误差              ← 比例项："我偏了多远？"
     + Ki × ∫误差 × dt        ← 积分项："我已经偏了多久？"
     + Kd × d误差/dt          ← 微分项："我在接近还是远离？"
```

**类比：** 想象你开车驶向红绿灯：
- **P**（比例）：离得越远，油门踩得越狠 → 可能会冲过头
- **I**（积分）：如果长期偏离，就加大力度 → 消除持续偏差
- **D**（微分）：如果接近得太快，开始刹车 → 减少超调

**可选增强功能**（6电机配置激活全部三项）：

| 增强功能 | 方法 | 作用 |
|---------|------|------|
| **抗饱和** | `set_integral_limit(limit)` | 将 `∫误差·dt` 钳位到 ±limit，防止电机饱和时积分爆炸（如推力对抗时） |
| **微分EMA滤波** | `set_d_filter(alpha)` | 低通滤波：`filtered = α×prev + (1-α)×raw`。平滑微分噪声尖峰。alpha=0禁用 |
| **输出钳位** | `set_output_limit(limit)` | 对称 ±limit 输出钳位。防止命令超过硬件能力 |

三项增强**默认禁用**（设为0）。2电机配置以基本模式运行PID。6电机运动代码在 `reset()` 后调用设置器激活竞赛级行为。

---

#### 运动规划

与其从0瞬间跳到最高速度（会导致轮子打滑和运动生硬），我们使用**梯形速度规划**：

```
速度
▲
│    ┌────────────┐
│   /              \
│  /                \
│ /                  \
└──────────────────────── 时间
  加速     巡航    减速
```

每一刻，目标速度 = min(加速限制, 最高速度, 减速限制)：

1. **加速限制**：`v = a × t` — 不能加速太快
2. **最高速度上限**：`v = v_max` — 不能超过极速
3. **减速限制**：`v = √(2 × a × d)` — 必须能及时停下来

三个约束中最小的那个获胜。

---

### 4.5 运动层 — 高层指令

**文件：**
- `include/motion/turn_to_heading.h` + `src/motion/turn_to_heading.cpp`
- `include/motion/drive_to_pose.h` + `src/motion/drive_to_pose.cpp`

#### 原地转向（turn_to_heading）

让机器人原地旋转到指定方向。使用PID控制朝向误差。

**算法：**
1. 计算朝向误差 = 目标 − 当前
2. 归一化到 [-π, +π]（总是走近路）
3. PID → 角速度 → 差速轮电压
4. 当误差在 `TURN_SETTLE_TIME_MS` 内保持很小时退出，或超时退出

**6电机增强：** `reset()` 后，转向PID激活抗饱和（`TURN_INTEGRAL_LIMIT`）、微分滤波（`TURN_D_FILTER`）和输出钳位（12V），在高扣力底盘上实现更平滑精确的转向。

**退出条件（为什么需要两个？）：**
- **稳定时间**：确保机器人真的停了，不是只是路过目标值
- **超时**：安全网 — 如果出了问题，不要永远转下去

---

#### 驶向目标点（drive_to_pose）

驱动机器人到场地上的指定 (x, y, θ) 位姿。策略因配置而异：

**2电机 — 先转后行**（入门级）：
1. **第一步 — 转向**：原地旋转面向目标点
2. **第二步 — 行驶**：用运动规划的速度前进 + 朝向修正

```
         目标点 (x, y)
            ●
           /
          /  ← 第二步：向前行驶
         /
        /
    ●──→    ← 第一步：转向面对目标
  起点
```

**6电机 — 回旋镞控制器**（竞赛级）：
不停下来转向，而是在目标点沿其朝向向量后方放置一个“胡萝卜”引导点。机器人瞬准胡萝卜；随着距离缩小，胡萝卜收敛到目标，产生平滑曲线接近，到达时朝向正确。

```
         胡萝卜 ◀── lead ──── 目标
           ╱                     ↑ θ_最终
        机器人
```

**回旋镞特性：**
- 平滑曲线接近 — 无中间停顿
- 最终朝向控制 — 到达时面向期望方向
- 支持倒车（`reverse=true` 参数）
- 余弦扩流 — 朝向误差大时减速
- 加速度撑流率限制 — 防止轮子打滑
- 完整角度PID，带抗饱和、D滤波和输出钳位

---

### 4.6 主程序入口

**文件：** `src/main.cpp`

入口程序将所有东西粘合在一起。它使用 `#ifdef` 为选定的配置创建正确的电机对象：

- **2电机**：2个电机 → `LeftDriveSmart`、`RightDriveSmart`
- **6电机**：6个电机 → `LeftFront/Mid/Rear`、`RightFront/Mid/Rear`（蓝色齿轮盒，左侧反转）

注意：6电机配置中的电机 `reverse` 标志考虑了物理安装方向 — 左侧电机与右侧电机面向相反。

---

## 5. 数据流

以下是自主模式中数据在系统中的流动方式：

```
编码器 + IMU
      │
      ▼
  ┌────────────┐
  │   里程计    │──→ 位姿 {x, y, θ}
  └────────────┘         │
                         ▼
              ┌──────────────────┐
              │   drive_to_pose  │
              │   或              │
              │  turn_to_heading │
              └──────────────────┘
                    │         │
          ┌─────────┘         └──────────┐
          ▼                              ▼
   ┌──────────────┐              ┌──────────────┐
   │  运动规划     │              │     PID      │
   │（目标速度）    │              │（修正值）     │
   └──────────────┘              └──────────────┘
          │                              │
          └──────────┬───────────────────┘
                     ▼
              ┌──────────────┐
              │  HAL 电机    │──→ 轮子电压
              └──────────────┘
```

---

## 6. 核心算法

### 角度归一化

计算两个角度的差值时，结果必须在 [-π, +π] 范围内，以确保机器人总是走最短路线：

```cpp
error = atan2(sin(error), cos(error));
```

没有这个处理，从350°转到10°会走远路（转340°）而不是近路（转20°）。

---

### 差速驱动运动学

轮速与机器人运动之间的转换：

```
正向：                       逆向：
v = (v右 + v左) / 2          v左 = v - ω × W/2
ω = (v右 - v左) / W          v右 = v + ω × W/2

其中：
  v   = 线速度（米/秒）
  ω   = 角速度（弧度/秒）
  W   = 轮距（米）
  v左  = 左轮速度
  v右  = 右轮速度
```

---

## 7. 架构优势展示

6电机配置证明了架构设计的正确性：

### 灵活性（适应不同硬件）
- 从2电机切换到6电机只需修改含有 **`#ifdef` 配置块**的少量文件
- `config.h` 中的一个 `#define` 选择整个配置
- 编译时守卫防止无效组合
- 配置相关行为（回旋镞、增量融合）被隔离在 `#ifdef`/`#else` 块中 — 2电机代码路径始终保持不变

### 可复用性（相同代码，不同机器人）
- `PIDController` 类在两种配置中完全相同 — 只有*增益*和可选增强不同
- `MotionProfile` 无需修改 — 只有 `MAX_VELOCITY` 和 `MAX_ACCELERATION` 不同
- HAL API（`get_left_encoder_ticks()`、`set_drive_motors()`）隐藏了所有多电机复杂性
- 里程计、drive_to_pose、turn_to_heading 共享相同API — 配置相关行为在编译时选择

### 可扩展性（容易添加更多配置）
- 添加8电机配置（例如麦克纳姆轮）遵循相同模式：
  1. 在 `config.h` 中添加 `#define ROBOT_8MOTOR` 部分
  2. 在 `motors.cpp` 中添加电机控制逻辑
  3. 在 `main.cpp` 中添加电机声明
  4. 所有其他文件保持不变
- 添加子系统（吸取器、投石器、气动）遵循相同的HAL模式

### 关注点分离
```
  什么变了              在哪里              什么没变
  ─────────────        ──────────────      ───────────────────
  电机数量         →   motors.cpp          PID算法
  电机端口         →   config.h            里程计数学
  轮子尺寸         →   config.h            运动规划
  PID增益          →   config.h            驶向目标点逻辑
  齿轮盒类型       →   main.cpp            转向指定朝向逻辑
```

---

## 8. 未来路线图

这个代码库设计用于向上成长。以下是自然的下一步，按影响力排序：

| 优先级 | 功能 | 难度 | 状态 |
|--------|------|------|------|
| 1 | **在真实机器人上调PID** | 简单 | 持续进行 — 在场地调试 |
| 2 | **添加机构**（吸取器、升降、夹持） | 简单 | 下一步 |
| ~~3~~ | ~~**PID抗饱和**~~ | ~~中等~~ | ✅ 已完成 — `set_integral_limit()` |
| ~~3b~~ | ~~**PID微分滤波**~~ | ~~简单~~ | ✅ 已完成 — `set_d_filter()` |
| ~~3c~~ | ~~**PID输出钳位**~~ | ~~简单~~ | ✅ 已完成 — `set_output_limit()` |
| ~~4~~ | ~~**IMU朝向绕回修复**~~ | ~~中等~~ | ✅ 已完成 — 增量IMU融合（6M） |
| ~~5~~ | ~~**曲线路径跟随**~~ | ~~困难~~ | ✅ 已完成 — 回旋镞控制器（6M） |
| 6 | **跟踪轮**里程计 | 中等 | 未来 — 更精确的定位 |
| 7 | **S曲线运动规划** | 中等 | 未来 — 限制加加速度 |
| 8 | **卡尔曼滤波器**定位 | 困难 | 未来 — 最优传感器融合 |
| 9 | **视觉传感器集成** | 困难 | 未来 — 绝对位置修正 |

---

## 文件地图

```
v5competition1/
├── include/
│   ├── config.h                    ← 所有可调参数
│   ├── vex.h                       ← VEX SDK头文件
│   ├── hal/
│   │   ├── motors.h                ← 电机函数
│   │   ├── imu.h                   ← IMU函数
│   │   └── time.h                  ← 时间函数
│   ├── localization/
│   │   └── odometry.h              ← 位置追踪
│   ├── control/
│   │   ├── pid.h                   ← PID控制器
│   │   └── motion_profile.h        ← 速度规划
│   └── motion/
│       ├── turn_to_heading.h       ← 转向指令
│       └── drive_to_pose.h         ← 行驶指令
├── src/
│   ├── main.cpp                    ← 入口程序
│   ├── hal/     (*.cpp)            ← HAL实现
│   ├── localization/ (*.cpp)       ← 里程计实现
│   ├── control/ (*.cpp)            ← 算法实现
│   └── motion/  (*.cpp)            ← 指令实现
├── test/
│   └── host_tests.cpp              ← 主机端单元测试
└── docs/
    ├── en/                         ← 英文文档
    └── cn/                         ← 中文文档
```
