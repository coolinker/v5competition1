# 设计文档 — VEX V5 机器人软件架构

---

## 目录

1. [概述](#1-概述)
2. [系统架构](#2-系统架构)
3. [逐层设计](#3-逐层设计)
   - 3.1 [配置层](#31-配置层)
   - 3.2 [硬件抽象层（HAL）](#32-硬件抽象层hal)
   - 3.3 [定位层 — 里程计](#33-定位层--里程计)
   - 3.4 [控制层 — PID 与运动规划](#34-控制层--pid-与运动规划)
   - 3.5 [运动层 — 高层指令](#35-运动层--高层指令)
   - 3.6 [主程序入口](#36-主程序入口)
4. [数据流](#4-数据流)
5. [核心算法](#5-核心算法)
6. [未来路线图](#6-未来路线图)

---

## 1. 概述

本项目是为 VEX V5 竞赛机器人设计的模块化软件架构。设计目标：

- **上手简单** — 开箱即用，适用于基础差速驱动机器人
- **容易理解** — 每个文件只负责一件事
- **可扩展** — 随时可以升级为顶级竞赛代码库

机器人使用**差速驱动**（左右各一个动力轮）。软件提供：

1. **位置追踪**（里程计）— "我在场地上的哪里？"
2. **PID 控制** — "怎样平稳地到达目标？"
3. **运动规划** — "怎样平滑地加速和减速？"
4. **自主运动** — "开到这个点" 或 "转到这个朝向"

---

## 2. 系统架构

软件按**分层**组织，像一摞积木。上层使用下层，但下层绝不依赖上层。

```
┌─────────────────────────────────────────────┐
│              main.cpp                       │  ← 应用层（最顶层）
│          （竞赛回调函数）                      │
├─────────────────────────────────────────────┤
│     motion/                                 │  ← 运动指令层
│   turn_to_heading    drive_to_pose          │     "转90°"、"开到(1,0)"
├─────────────────────────────────────────────┤
│     control/                                │  ← 算法层
│   PIDController      MotionProfile          │     PID数学、速度规划
├─────────────────────────────────────────────┤
│     localization/                           │  ← 状态估计层
│   odometry (Pose: x, y, θ)                 │     "我在哪？"
├─────────────────────────────────────────────┤
│     hal/                                    │  ← 硬件抽象层
│   motors    imu    time                     │     与真实硬件通信
├─────────────────────────────────────────────┤
│     config.h                                │  ← 常量配置
│   （端口、尺寸、PID增益）                      │     唯一的参数来源
└─────────────────────────────────────────────┘
```

**为什么分层？**

- 可以在**没有硬件**的情况下测试上层逻辑（用模拟HAL）
- 可以只改 HAL 就**更换硬件**（换电机、传感器）
- 每一层可以独立开发和调试

---

## 3. 逐层设计

### 3.1 配置层

**文件：** `include/config.h`

一个头文件，包含所有可调参数。任何你可能需要修改的数字（轮子大小、电机端口、PID增益）都在这里。

| 常量 | 含义 | 示例值 |
|------|------|--------|
| `WHEEL_DIAMETER` | 轮子直径（米） | 0.1016（4英寸） |
| `WHEEL_TRACK` | 左右轮间距 | 0.381（15英寸） |
| `TICKS_PER_REV` | 编码器每转脉冲数 | 360 |
| `WHEEL_CIRCUMFERENCE` | 派生值：π × 直径 | 自动计算 |
| `TURN_KP/KI/KD` | 转弯PID增益 | 2.0 / 0.0 / 0.1 |
| `DRIVE_KP/KI/KD` | 直线行驶PID增益 | 5.0 / 0.0 / 0.3 |
| `MAX_VELOCITY` | 自主模式最高速度（米/秒） | 0.8 |
| `MAX_ACCELERATION` | 加速度（米/秒²） | 1.5 |
| `LOOP_INTERVAL_MS` | 控制循环周期 | 10毫秒 |

**为什么放在一个文件？** 在比赛现场调参时，只需要去一个地方改数字，不用翻遍10个文件。

---

### 3.2 硬件抽象层（HAL）

**文件：**
- `include/hal/motors.h` + `src/hal/motors.cpp`
- `include/hal/imu.h` + `src/hal/imu.cpp`
- `include/hal/time.h` + `src/hal/time.cpp`

HAL是对VEX硬件的薄封装。它提供简单函数，隐藏VEX特定的API：

```
VEX API（复杂）                HAL（简单）
──────────────                 ────────────
motor.spin(fwd, 8, volt)  →   set_drive_motors(8.0, 8.0)
motor.stop(brake)          →   stop_drive_motors()
motor.position(degrees)    →   get_left_encoder_ticks()
inertial.heading(degrees)  →   get_imu_heading_rad()
```

**核心函数：**

| 模块 | 函数 | 功能 |
|------|------|------|
| motors | `set_drive_motors(left_v, right_v)` | 设置左/右电机电压（-12到+12） |
| motors | `stop_drive_motors()` | 刹车停止两个电机 |
| motors | `get_left_encoder_ticks()` | 读取左轮编码器 |
| motors | `get_right_encoder_ticks()` | 读取右轮编码器 |
| motors | `reset_encoders()` | 两个编码器归零 |
| imu | `get_imu_heading_rad()` | 当前朝向（弧度）[0, 2π) |
| imu | `get_imu_rotation_rad()` | 无界旋转角度（可超过2π） |
| imu | `calibrate_imu()` | 校准IMU并等待完成 |
| imu | `reset_imu()` | 朝向归零 |
| time | `get_time_sec()` | 当前时间（秒） |
| time | `get_time_ms()` | 当前时间（毫秒） |
| time | `wait_ms(ms)` | 休眠若干毫秒 |

**设计决策：** 电机电压在HAL内部被限制在[-12, +12]，上层代码不需要担心超出硬件极限。

---

### 3.3 定位层 — 里程计

**文件：** `include/localization/odometry.h` + `src/localization/odometry.cpp`

里程计回答这个问题：**"我的机器人在场地上的哪里？"**

它追踪机器人的**位姿（Pose）**——位置和朝向的组合：

```
Pose = { x, y, θ }
         ↑  ↑  ↑
         │  │  └── 朝向角度（弧度，0 = 面向右/+X方向）
         │  └───── Y 位置（米，从起点向前）
         └──────── X 位置（米，从起点向右）
```

**工作原理（逐步说明）：**

1. **读取编码器** — 获取左右轮的总脉冲数
2. **计算增量脉冲** — 减去上次读数，得到自上次更新以来的变化
3. **转换为米** — `增量米数 = 增量脉冲 × (轮周长 / 每转脉冲数)`
4. **计算机器人运动：**
   - 线性距离：`d = (d左 + d右) / 2`
   - 编码器推算的朝向变化：`dθ_编码器 = (d右 - d左) / 轮距`
5. **与IMU融合** — 混合编码器朝向和IMU朝向：
   - `θ = α × θ_IMU + (1-α) × θ_编码器`，其中 α = 0.98（更信任IMU）
6. **更新位置**，使用中点近似法：
   - `x += d × cos(θ_中间)`
   - `y += d × sin(θ_中间)`

**为什么要IMU融合？** 编码器在轮子打滑时会漂移。IMU不会打滑，但会随时间缓慢漂移。两者结合可获得最佳精度。

---

### 3.4 控制层 — PID 与运动规划

**文件：**
- `include/control/pid.h` + `src/control/pid.cpp`
- `include/control/motion_profile.h` + `src/control/motion_profile.cpp`

#### PID 控制器

PID控制器就像一个智能恒温器，持续调整输出以达到目标：

```
误差 = 目标值 - 当前值

输出 = Kp × 误差              ← 比例项："我偏了多远？"
     + Ki × ∫误差 × dt        ← 积分项："我已经偏了多久？"
     + Kd × d误差/dt          ← 微分项："我在接近还是远离？"
```

**类比：** 想象你开车驶向红绿灯：
- **P**（比例）：离得越远，油门踩得越狠 → 可能会冲过头
- **I**（积分）：如果长期偏离，就加大力度 → 消除持续偏差
- **D**（微分）：如果接近得太快，开始刹车 → 减少超调

---

#### 运动规划

与其从0瞬间跳到最高速度（会导致轮子打滑和运动生硬），我们使用**梯形速度规划**：

```
速度
▲
│    ┌────────────┐
│   /              \
│  /                \
│ /                  \
└──────────────────────── 时间
  加速     巡航    减速
```

每一刻，目标速度 = min(加速限制, 最高速度, 减速限制)：

1. **加速限制**：`v = a × t` — 不能加速太快
2. **最高速度上限**：`v = v_max` — 不能超过极速
3. **减速限制**：`v = √(2 × a × d)` — 必须能及时停下来

三个约束中最小的那个获胜。

---

### 3.5 运动层 — 高层指令

**文件：**
- `include/motion/turn_to_heading.h` + `src/motion/turn_to_heading.cpp`
- `include/motion/drive_to_pose.h` + `src/motion/drive_to_pose.cpp`

#### 原地转向（turn_to_heading）

让机器人原地旋转到指定方向。使用PID控制朝向误差。

**算法：**
1. 计算朝向误差 = 目标 − 当前
2. 归一化到 [-π, +π]（总是走近路）
3. PID → 角速度 → 差速轮电压
4. 当误差在 `TURN_SETTLE_TIME_MS` 内保持很小时退出，或超时退出

**退出条件（为什么需要两个？）：**
- **稳定时间**：确保机器人真的停了，不是只是路过目标值
- **超时**：安全网 — 如果出了问题，不要永远转下去

---

#### 驶向目标点（drive_to_pose）

驱动机器人到场地上的指定 (x, y) 坐标。两步走策略：

1. **第一步 — 转向**：原地旋转面向目标点
2. **第二步 — 行驶**：用运动规划的速度前进
   - 运动规划提供平滑的加速/减速
   - 朝向修正保持直线行驶（补偿漂移）

```
         目标点 (x, y)
            ●
           /
          /  ← 第二步：向前行驶
         /
        /
    ●──→    ← 第一步：转向面对目标
  起点
```

---

### 3.6 主程序入口

**文件：** `src/main.cpp`

入口程序将所有东西粘合在一起：

1. **硬件定义** — 创建电机、IMU和主控对象
2. **`pre_auton()`** — 启动时校准IMU
3. **`autonomous()`** — 15秒自主程序（包含L形路径示例）
4. **`usercontrol()`** — 左右摇杆坦克驱动
5. **`main()`** — 向VEX竞赛系统注册回调，然后运行里程计后台循环

**如何定制：** 只需编辑 `autonomous()` 和 `usercontrol()`。其他都是基础设施。

---

## 4. 数据流

以下是自主模式中数据在系统中的流动方式：

```
编码器 + IMU
      │
      ▼
  ┌────────────┐
  │   里程计    │──→ 位姿 {x, y, θ}
  └────────────┘         │
                         ▼
              ┌──────────────────┐
              │   drive_to_pose  │
              │   或              │
              │  turn_to_heading │
              └──────────────────┘
                    │         │
          ┌─────────┘         └──────────┐
          ▼                              ▼
   ┌──────────────┐              ┌──────────────┐
   │  运动规划     │              │     PID      │
   │（目标速度）    │              │（修正值）     │
   └──────────────┘              └──────────────┘
          │                              │
          └──────────┬───────────────────┘
                     ▼
              ┌──────────────┐
              │  HAL 电机    │──→ 轮子电压
              └──────────────┘
```

---

## 5. 核心算法

### 角度归一化

计算两个角度的差值时，结果必须在 [-π, +π] 范围内，以确保机器人总是走最短路线：

```cpp
error = atan2(sin(error), cos(error));
```

没有这个处理，从350°转到10°会走远路（转340°）而不是近路（转20°）。

---

### 差速驱动运动学

轮速与机器人运动之间的转换：

```
正向：                       逆向：
v = (v右 + v左) / 2          v左 = v - ω × W/2
ω = (v右 - v左) / W          v右 = v + ω × W/2

其中：
  v   = 线速度（米/秒）
  ω   = 角速度（弧度/秒）
  W   = 轮距（米）
  v左  = 左轮速度
  v右  = 右轮速度
```

---

## 6. 未来路线图

这个代码库设计用于向上成长。以下是自然的下一步，按影响力排序：

| 优先级 | 功能 | 难度 | 收益 |
|--------|------|------|------|
| 1 | **在真实机器人上调PID** | 简单 | 其他一切都依赖于此 |
| 2 | **添加机构**（吸取器、升降、夹持） | 简单 | 针对比赛的得分机构 |
| 3 | **PID抗饱和** | 中等 | 防止输出饱和时积分累积 |
| 4 | **跟踪轮**里程计 | 中等 | 更精确的位置追踪 |
| 5 | **纯追踪**路径跟随 | 困难 | 平滑曲线路径替代"转向-行驶" |
| 6 | **S曲线运动规划** | 中等 | 限制加加速度（jerk），减少轮子打滑 |
| 7 | **卡尔曼滤波器**定位 | 困难 | 噪声下的最优传感器融合 |
| 8 | **视觉传感器集成** | 困难 | 绝对位置修正、物体检测 |

---

## 文件地图

```
v5competition1/
├── include/
│   ├── config.h                    ← 所有可调参数
│   ├── vex.h                       ← VEX SDK头文件
│   ├── hal/
│   │   ├── motors.h                ← 电机函数
│   │   ├── imu.h                   ← IMU函数
│   │   └── time.h                  ← 时间函数
│   ├── localization/
│   │   └── odometry.h              ← 位置追踪
│   ├── control/
│   │   ├── pid.h                   ← PID控制器
│   │   └── motion_profile.h        ← 速度规划
│   └── motion/
│       ├── turn_to_heading.h       ← 转向指令
│       └── drive_to_pose.h         ← 行驶指令
├── src/
│   ├── main.cpp                    ← 入口程序
│   ├── hal/     (*.cpp)            ← HAL实现
│   ├── localization/ (*.cpp)       ← 里程计实现
│   ├── control/ (*.cpp)            ← 算法实现
│   └── motion/  (*.cpp)            ← 指令实现
├── test/
│   └── host_tests.cpp              ← 主机端单元测试
└── docs/
    ├── en/                         ← 英文文档
    └── cn/                         ← 中文文档
```
