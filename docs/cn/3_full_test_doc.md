# 完整测试文档 — VEX V5 机器人

---

## 目录

1. [测试策略概述](#1-测试策略概述)
2. [测试层级](#2-测试层级)
3. [第1级：主机端单元测试](#3-第1级主机端单元测试)
4. [第2级：机器人上组件测试](#4-第2级机器人上组件测试)
5. [第3级：集成测试](#5-第3级集成测试)
6. [第4级：系统测试](#6-第4级系统测试)
7. [第5级：竞赛就绪检查](#7-第5级竞赛就绪检查)
8. [PID调参指南](#8-pid调参指南)
9. [测试清单](#9-测试清单)
10. [常见故障模式](#10-常见故障模式)

---

## 1. 测试策略概述

测试竞赛机器人涉及**5个层级**，从笔记本上的纯软件到场地上的完整比赛模拟：

```
第5级：竞赛就绪检查     ← 完整比赛模拟
第4级：系统测试         ← 完整自主程序
第3级：集成测试         ← 多个模块协同工作
第2级：机器人组件测试    ← 单个硬件功能
第1级：主机端单元测试    ← 纯数学，不需要硬件
```

**经验法则：**
- **第1级**能发现约60%的bug（数学错误、逻辑错误）
- **第2-3级**能发现约30%的bug（硬件问题、时序）
- **第4-5级**能发现约10%的bug（场地条件、策略）

从第1级开始，逐级往上。不要跳过层级！

---

## 2. 测试层级

| 层级 | 运行环境 | 测试内容 | 何时运行 |
|------|---------|---------|---------|
| 1 | 你的电脑 | PID数学、运动规划、里程计 | 每次代码修改后 |
| 2 | 机器人（静止） | 电机转动、IMU读数、编码器计数 | 硬件更改后 |
| 3 | 机器人（运动） | 里程计跟踪、PID收敛 | PID增益修改后 |
| 4 | 机器人在场地上 | 完整自主路线 | 比赛前 |
| 5 | 比赛模拟 | 完整比赛，手动+自主 | 前一天/当天早上 |

---

## 3. 第1级：主机端单元测试

这些测试在你的开发电脑上用 `make test` 运行。不需要机器人。

**覆盖的模块：**

| 模块 | 测试数 | 验证内容 |
|------|--------|---------|
| PID控制器 | 6 | P/I/D各项、零误差、重置 |
| 运动规划 | 5 | 加速/巡航/减速阶段、边界 |
| 里程计 | 6 | 前进/后退/转弯/累积 |
| **总计** | **17** | |

**运行方法：**
```bash
cd v5competition1
make test
```

**通过标准：** 所有17个测试显示 `[ OK ]`，退出码为0。

详细测试用例描述见[单元测试文档](../cn/2_unit_test_doc.md)。

---

## 4. 第2级：机器人上组件测试

这些测试验证每个硬件是否工作正常。将机器人架空（轮子离地）或放在光滑表面上运行。

### 测试 2.1：电机方向检查

**步骤：**
1. 将机器人抬起，轮子离地
2. 在 `usercontrol()` 中，向前推左摇杆
3. **观察：** 左轮向前转
4. 向前推右摇杆
5. **观察：** 右轮向前转

**如果方向错误：** 电机反了。在 `main.cpp` 的电机构造函数中翻转 `true/false` 参数，或交换电机端口。

**通过标准：** 向前推摇杆时两轮都向前转。

---

### 测试 2.2：编码器验证

**步骤：**
1. 在 `main()` 循环中添加临时调试输出：
   ```cpp
   Brain.Screen.clearLine(2);
   Brain.Screen.setCursor(2, 1);
   Brain.Screen.print("L: %.1f  R: %.1f",
       get_left_encoder_ticks(), get_right_encoder_ticks());
   ```
2. 手动将每个轮子向前转一整圈
3. **观察：** 编码器读数约 `TICKS_PER_REV`（360）
4. 向后旋转
5. **观察：** 编码器减少

**通过标准：**
- 前进一整圈 ≈ 360脉冲（±5）
- 方向正确：前进 = 正值

---

### 测试 2.3：IMU校准和朝向

**步骤：**
1. 将机器人放在平坦稳定的表面上
2. 开机 — 等待屏幕显示 "Ready."（IMU校准中）
3. 添加调试输出：
   ```cpp
   Brain.Screen.print("IMU: %.2f rad", get_imu_heading_rad());
   ```
4. **观察：** 校准后读数 ≈ 0.0
5. 用手将机器人顺时针旋转90°
6. **观察：** 读数 ≈ π/2（1.57）
7. 再旋转90°（共180°）
8. **观察：** 读数 ≈ π（3.14）

**通过标准：**
- 校准后：朝向 ≈ 0
- 旋转90°后：朝向 ≈ 1.57 ± 0.1
- 旋转180°后：朝向 ≈ 3.14 ± 0.1

---

## 5. 第3级：集成测试

测试多个模块协同工作。机器人必须运动。

### 测试 3.1：里程计精度 — 直线

**步骤：**
1. 将机器人放在已知起始位置
2. 在地面上标记前方正好1米的点（用胶带/尺子）
3. 在自主模式中运行：
   ```cpp
   set_pose({0, 0, 0});
   // 用手动控制向前开1米
   ```
4. 在屏幕上显示位姿：
   ```cpp
   Pose p = get_pose();
   Brain.Screen.print("x=%.3f y=%.3f", p.x, p.y);
   ```
5. 用手推机器人前进正好1米（或小心驾驶）

**通过标准：**
- x ≈ 1.0 ± 0.05（5厘米以内）
- y ≈ 0.0 ± 0.03

**如果失败：** 检查 config.h 中的 `WHEEL_DIAMETER` 和 `TICKS_PER_REV`。用游标卡尺测量实际轮子直径。

---

### 测试 3.2：里程计精度 — 原地转弯

**步骤：**
1. 把机器人放在地上，用胶带标记朝向
2. `set_pose({0, 0, 0})`
3. 手动旋转机器人360°（回到起始方向）
4. 检查位姿：θ 应该 ≈ 0（或 ≈ 2π）

**通过标准：**
- 位置 (x, y) 应仍然 ≈ (0, 0) ± 0.05米
- 360°后：θ 误差 < 0.1弧度（≈ 6°）

**如果失败：** 检查 config.h 中的 `WHEEL_TRACK`。测量轮子接地点之间的实际距离。

---

### 测试 3.3：转向精度

**步骤：**
1. `set_pose({0, 0, 0})`
2. 运行 `turn_to_heading(M_PI / 2.0)`（左转90°）
3. 用量角器或参照场地标记测量实际朝向

**通过标准：**
- 最终朝向在目标的 ±5° 以内
- 机器人平稳停下（没有剧烈震荡）
- 在 TURN_TIMEOUT_MS 内完成

**如果失败：**
- 震荡：减小 TURN_KP 或增大 TURN_KD
- 到不了目标：增大 TURN_KP
- 太慢：增大 TURN_KP

---

### 测试 3.4：行驶精度

**步骤：**
1. 标记起始位置和前方1.0米的点
2. `set_pose({0, 0, 0})`
3. 运行 `drive_to_pose({1.0, 0, 0})`
4. 测量实际停止位置

**通过标准：**
- 在目标5厘米以内停下
- 没有明显冲过头
- 行驶路线基本是直线

**如果失败：**
- 冲过头：减小 MAX_VELOCITY 或增大 MAX_ACCELERATION
- 偏向一侧：检查 HEADING_CORRECTION_KP，检查两边轮子直径是否一致
- 停在目标之前：检查 DRIVE_SETTLE_M 容差

---

## 6. 第4级：系统测试

系统测试在真实场地（或练习场）上运行完整自主程序。目标是验证完整路径端到端工作。

### 测试 4.1：L形路径自主

**步骤：**
1. 准备一个有1米×0.8米空间的练习场
2. 把机器人放在起始位置
3. 运行自主程序：
   ```cpp
   set_pose({0, 0, 0});
   drive_to_pose({1.0, 0.0, 0});    // 前进1米
   turn_to_heading(M_PI / 2.0);     // 左转90°
   drive_to_pose({1.0, 0.8, 0});    // 侧向0.8米
   ```
4. 记录：机器人是否按照预期的L形路径行驶？

**通过标准：**
- 机器人前进约1米，左转约90°，再行驶约0.8米
- 最终位置在预期终点的10厘米以内
- 没有碰撞，运动平滑

---

### 测试 4.2：重复性测试

**步骤：**
1. 从完全相同的起始位置运行相同的自主程序5次
2. 每次标记最终位置

**通过标准：**
- 所有5次最终位置在10厘米×10厘米的框内
- 时间一致（±0.5秒以内）

**为什么重要：** 在比赛中，你需要相信自主程序每次都做同样的事。

---

### 测试 4.3：超时安全测试

**步骤：**
1. 在自主运动期间抓住机器人不让它动（轮子无法转动）
2. **观察：** 机器人应在超时时间（2-5秒）后停止尝试

**通过标准：**
- 机器人不会永远转电机
- 电机在 TURN_TIMEOUT_MS 或 DRIVE_TIMEOUT_MS 后停止
- 程序继续执行下一个动作

---

## 7. 第5级：竞赛就绪检查

每次比赛前运行此清单：

### 赛前清单

- [ ] **电池：** 充满电（> 95%）
- [ ] **固件：** V5主控固件已更新
- [ ] **代码编译：** `make` 构建无错误
- [ ] **单元测试通过：** `make test` → 17/17
- [ ] **IMU校准：** 3秒内屏幕显示 "Ready."
- [ ] **电机检查：** 所有电机方向正确（测试2.1）
- [ ] **编码器检查：** 两个编码器计数正确（测试2.2）
- [ ] **自主运行：** L形路径正确完成（测试4.1）
- [ ] **重复性：** 连续3次成功的自主运行（测试4.2）
- [ ] **超时有效：** 抓住机器人时停止（测试4.3）
- [ ] **手动控制：** 坦克驱动平稳
- [ ] **没有松动的线：** 所有连接牢固

### 比赛模拟流程

1. 把机器人放在场地上的起始位置
2. 运行完整的1分钟自主
3. 立即切换到1分钟手动控制
4. 记录任何问题
5. 重复3次

---

## 8. PID调参指南

PID调参是最重要的测试活动。PID增益不好 = 机器人表现不好。

### 逐步调参流程

> **黄金法则：** 一次只调一个参数。改一个数字，测试，重复。

#### 调整转弯PID（TURN_KP, TURN_KI, TURN_KD）：

1. **只用P开始：** 设 Ki=0, Kd=0, Kp=1.0
2. 运行 `turn_to_heading(M_PI / 2.0)`（90°转弯）
3. **增大Kp** 直到机器人果断转弯但轻微震荡
4. **加入Kd**（从Kp/10开始）。增大直到震荡停止
5. **只在需要时加Ki**（从Kp/100开始）。只在机器人持续停在目标之前时使用

| 症状 | 调整方法 |
|------|---------|
| 太慢，停在目标之前 | 增大 Kp |
| 震荡（来回摆动） | 增大 Kd，或减小 Kp |
| 冲过一次然后稳定 | 略微增大 Kd |
| 始终到不了目标 | 加入小的 Ki |
| 剧烈震荡，永远不停 | Kp太高了 — 减半 |

#### 调整直线行驶PID（DRIVE_KP, DRIVE_KI, DRIVE_KD）：

同样的流程，但用 `drive_to_pose({1.0, 0, 0})` 测试。

#### 调参技巧：

- **录像** — 视频可以让你逐帧分析行为
- **记录数据** — 在屏幕或SD卡上打印（时间、误差、输出）
- **在实际比赛表面调参** — 瓷砖和地毯的摩擦力不同！
- **为最坏情况调参** — 加重量、低电量、轮子打滑

---

## 9. 测试清单

使用此表格跟踪测试进度。通过标 ✅，失败标 ❌，未测试标 ⬜。

```
=== 第1级：主机端单元测试 ===
⬜ make test → 17/17 通过

=== 第2级：组件测试 ===
⬜ 2.1  电机方向
⬜ 2.2  编码器精度
⬜ 2.3  IMU校准和朝向

=== 第3级：集成测试 ===
⬜ 3.1  里程计直线精度
⬜ 3.2  里程计转弯精度
⬜ 3.3  转向精度
⬜ 3.4  行驶精度

=== 第4级：系统测试 ===
⬜ 4.1  L形路径自主
⬜ 4.2  重复性（5次）
⬜ 4.3  超时安全

=== 第5级：竞赛就绪 ===
⬜ 完整赛前清单
⬜ 比赛模拟（3次）
```

---

## 10. 常见故障模式

| # | 症状 | 可能原因 | 修复 |
|---|------|---------|------|
| 1 | 机器人走弧线不走直线 | 左右轮直径或摩擦力不同 | 检查轮子，调整 HEADING_CORRECTION_KP |
| 2 | 里程计位置随时间漂移 | 轮子打滑，WHEEL_DIAMETER不准 | 精确测量轮径，考虑使用跟踪轮 |
| 3 | 转弯时机器人震荡（抖动） | Kp太高或Kd太低 | 减小Kp，增大Kd |
| 4 | 机器人达不到目标朝向 | Kp太低或摩擦力太大 | 增大Kp，检查机械卡顿 |
| 5 | 自主模式冲过目标位置 | 最大速度太高，减速段太短 | 减小MAX_VELOCITY或增大MAX_ACCELERATION |
| 6 | 撞墙后IMU朝向不对 | IMU被撞击干扰 | 这是正常现象。考虑重新校准 |
| 7 | 机器人永远旋转 | turn_to_heading没有超时 | 已通过TURN_TIMEOUT_MS修复！ |
| 8 | 在不同表面表现不同 | 摩擦力影响轮子打滑和PID响应 | 在比赛表面重新调参 |
| 9 | `make test`失败但机器人正常 | 测试检查数学，不是硬件行为 | 修复测试 — 数学应该始终正确 |
| 10 | 机器人工作但自主不一致 | 电池电量变化，轮子磨损 | 充电，检查轮子，在最坏情况调参 |

---

## 快速参考卡

```
╔══════════════════════════════════════════════╗
║         VEX V5 测试快速参考                    ║
╠══════════════════════════════════════════════╣
║                                              ║
║  运行单元测试：    make test                   ║
║  编译到机器人：    make                        ║
║                                              ║
║  配置文件：       include/config.h             ║
║  测试文件：       test/host_tests.cpp          ║
║                                              ║
║  PID调参顺序：    P → D → I                   ║
║  初始值：         Kp=1, Ki=0, Kd=0            ║
║                                              ║
║  关键测量：                                    ║
║    轮子直径：     用游标卡尺！                   ║
║    轮距：         中心到中心                     ║
║    每转脉冲：     转一整圈计数                   ║
║                                              ║
║  紧急情况：检查超时常量                          ║
║           TURN_TIMEOUT_MS = 2000              ║
║           DRIVE_TIMEOUT_MS = 5000             ║
║                                              ║
╚══════════════════════════════════════════════╝
```
