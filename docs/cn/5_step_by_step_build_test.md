# 逐步构建与调试指南 — VEX V5 六轮竞赛机器人

**从零到完整系统的渐进式构建、测试与调参最佳实践**

> **核心原则：每次只加一个模块，确认正常后再加下一个。**
> 绝对不要一口气插好所有传感器、烧完所有代码、然后祈祷它能跑。

---

## 目录

- [总体思路](#总体思路)
- [阶段 0：主机单元测试（不需要硬件）](#阶段-0主机单元测试不需要硬件)
- [阶段 1：最小底盘 — 只有电机](#阶段-1最小底盘--只有电机)
- [阶段 2：加入惯性传感器 (IMU)](#阶段-2加入惯性传感器-imu)
- [阶段 3：加入追踪轮](#阶段-3加入追踪轮)
- [阶段 4：里程计验证](#阶段-4里程计验证)
- [阶段 5：PID 转弯调参](#阶段-5pid-转弯调参)
- [阶段 6：PID 直线调参](#阶段-6pid-直线调参)
- [阶段 7：Boomerang 路径验证](#阶段-7boomerang-路径验证)
- [阶段 8：视觉定位（可选）](#阶段-8视觉定位可选)
- [阶段 9：完整自治路线](#阶段-9完整自治路线)
- [阶段 10：比赛就绪检查清单](#阶段-10比赛就绪检查清单)
- [附录 A：常见问题排查表](#附录-a常见问题排查表)
- [附录 B：调参速查表](#附录-b调参速查表)

---

## 总体思路

```
阶段 0  主机测试 (无硬件)
  ↓
阶段 1  电机 → 能开能走
  ↓
阶段 2  +IMU → 知道朝向
  ↓
阶段 3  +追踪轮 → 知道位置
  ↓
阶段 4  里程计验证 → 位置准确
  ↓
阶段 5  转弯 PID → 精准转弯
  ↓
阶段 6  直线 PID → 精准直线
  ↓
阶段 7  Boomerang → 弧线路径
  ↓
阶段 8  视觉定位 → 绝对校正 (可选)
  ↓
阶段 9  完整自治 → 比赛策略
  ↓
阶段 10 比赛就绪 → 上场
```

每个阶段包含三部分：
1. **硬件接线** — 需要接什么
2. **软件验证** — 怎么确认代码正常
3. **通过标准** — 达到什么指标才能进入下一阶段

---

## 阶段 0：主机单元测试（不需要硬件）

### 目标
在你的电脑上（Mac/Linux/Windows）验证所有数学算法正确，不需要任何 VEX 硬件。

### 步骤

#### 0.1 编译并运行测试

```bash
cd v5competition1
make test
```

#### 0.2 确认输出

你应该看到类似输出：

```
============================================
  VEX Robot Host-Side Unit Tests
  Config: 6-motor + perpendicular tracking wheels
============================================

[PID Controller]
  [ OK ] PID_PositiveErrorProducesPositiveOutput
  [ OK ] PID_NegativeErrorProducesNegativeOutput
  ...

[Odometry — Perpendicular Tracking Wheels]
  [ OK ] Odometry_DriveStraightForward
  [ OK ] Odometry_PointTurn90Degrees
  [ OK ] Odometry_LateralSlide
  ...

  Results: 24 passed, 0 failed, 24 total
  ALL TESTS PASSED
```

#### 0.3 理解测试覆盖

| 测试类别 | 测试数 | 验证内容 |
|---------|-------|---------|
| PID 基础 | 6 | P/I/D 各项独立正确、reset 清除状态 |
| PID 增强 | 6 | 积分抗饱和、微分滤波、输出钳位 |
| 运动规划 | 5 | 加速/匀速/减速/零距离/上限 |
| 里程计 | 7 | 直行/转弯/倒车/累积/弧线 |

### ✅ 通过标准
- 24/24 测试全部通过
- 如果失败，修复代码后重新运行，直到全部通过

---

## 阶段 1：最小底盘 — 只有电机

### 目标
确认 6 个电机全部能转、方向正确、速度正常。

### 硬件接线

| 设备 | 端口 | 备注 |
|------|-----|------|
| 左前电机 | Port 1 | 蓝色墨盒 600RPM，反转 |
| 左中电机 | Port 2 | 蓝色墨盒 600RPM，反转 |
| 左后电机 | Port 3 | 蓝色墨盒 600RPM，反转 |
| 右前电机 | Port 4 | 蓝色墨盒 600RPM，正转 |
| 右中电机 | Port 5 | 蓝色墨盒 600RPM，正转 |
| 右后电机 | Port 6 | 蓝色墨盒 600RPM，正转 |

> ⚠️ **左侧电机设为反转 (reversed=true)**，因为物理安装方向相反。

### 软件验证

#### 1.1 烧录程序到 V5 Brain

在 VS Code 中：按 `Ctrl+Shift+P` → 选择 `VEX: Build and Upload`

#### 1.2 手柄操控测试

程序编译上传后，连接手柄，切换到 `Driver Control` 模式：
- **左摇杆上推** → 机器人左侧轮子前进
- **右摇杆上推** → 机器人右侧轮子前进
- **两个摇杆同时上推** → 机器人直线前进
- **左推右拉** → 机器人右转

```
手柄操控映射 (坦克驱动):
  左摇杆 (Axis3) → 左侧 3 个电机电压
  右摇杆 (Axis2) → 右侧 3 个电机电压
  
  电压 = 摇杆百分比 × 12V
  死区: |摇杆| < 5% 视为 0
```

#### 1.3 检查项

| # | 检查项 | 预期 | 如果不正常 |
|---|--------|------|-----------|
| 1 | 6 个电机全部转动 | 无不动的电机 | 检查端口接线、电机线缆 |
| 2 | 左侧 3 个电机同向 | 推左摇杆，3 个轮子同时向前 | 有一个反了 → `config.h` 中检查端口分配或在 `main.cpp` 中翻转 reversed 参数 |
| 3 | 右侧 3 个电机同向 | 推右摇杆，3 个轮子同时向前 | 同上 |
| 4 | 两侧推同方向 → 直行 | 机器人基本走直线（允许轻微偏移） | 检查同侧电机齿轮比是否一致 |
| 5 | 全速无异响 | 电机声音正常，无咔哒声 | 机械问题：齿轮啮合、轴弯曲 |

#### 1.4 Brain 屏幕检查

开机后屏幕应显示：
```
=== 6M Tracking Odom ===
X: 0.000 m
Y: 0.000 m
Heading: 0.0 deg
```

> 此时位姿数据不会正确更新（还没接 IMU 和追踪轮），这是正常的。

### ✅ 通过标准
- 6 个电机全部能控制
- 同侧 3 个电机方向一致
- 两侧推同方向时机器人前进
- Brain 屏幕有显示（不黑屏）

---

## 阶段 2：加入惯性传感器 (IMU)

### 目标
确认 IMU 校准成功、航向读数准确。

### 硬件接线

在阶段 1 基础上，加入：

| 设备 | 端口 | 备注 |
|------|-----|------|
| V5 惯性传感器 | Port 10 | 尽量装在底盘中心，远离电机 |

> ⚠️ **安装要求：** IMU 必须水平安装，不能歪斜，否则读数会有偏差。

### 软件验证

#### 2.1 校准确认

烧录上传后，观察 Brain 屏幕：
```
Initializing...
INF IMU calibration started      ← 看到这条
INF IMU calibration finished     ← 3 秒内看到这条 = 成功
```

如果看到：
```
INF IMU calibration TIMEOUT
```
说明 IMU 没插好或端口不对。

#### 2.2 航向测试

1. 烧录后，把机器人放在地上，屏幕应显示 `Heading: 0.0 deg`
2. **用手逆时针转动机器人 90°** → 应显示 `Heading: ~90 deg`
3. **继续转回原位** → 应回到 `Heading: ~0 deg`
4. **顺时针转 90°** → 应显示 `Heading: ~-90 deg` 或 `~270 deg`

#### 2.3 校准建议

- 校准期间（约 2 秒）机器人**必须静止不动**
- 不要在电机运行时校准（振动影响精度）
- 校准后不要碰撞 Brain，会影响内部陀螺仪

### ✅ 通过标准
- IMU 校准在 3 秒内完成（无 TIMEOUT）
- 手动旋转 90°，屏幕显示 85°~95° 范围内
- 转一整圈回原位，误差 < 5°

---

## 阶段 3：加入追踪轮（垂直双轮方案）

### 目标
确认纵向追踪轮和横向追踪轮能正确读取距离，方向正确。

### 硬件接线

在阶段 2 基础上，加入：

| 设备 | 端口 | 备注 |
|------|-----|------|
| 纵向追踪轮旋转传感器 | Port 8 | 2.75" 全向轮 + V5 Rotation Sensor，平行于前进方向 |
| 横向追踪轮旋转传感器 | Port 9 | 2.75" 全向轮 + V5 Rotation Sensor，垂直于前进方向 |

> ⚠️ **安装要求：**
> - 追踪轮必须始终贴地（用弹簧浮动支架）
> - **纵向轮**沿机器人前进方向安装，尽量靠近中轴线
> - **横向轮**垂直于前进方向安装（测量左右滑动距离）
> - 测量横向轮相对于旋转中心的前后偏移，填入 `config.h` 的 `LATERAL_WHEEL_OFFSET`
> - 测量纵向轮相对于旋转中心的左右偏移，填入 `config.h` 的 `FORWARD_WHEEL_OFFSET`

### 软件验证

#### 3.1 连接检查

烧录后，屏幕应不显示 `Tracking wheels NOT detected!`

如果显示了这条警告，检查：
- 旋转传感器是否插在 Port 8 和 Port 9
- 传感器线缆是否插紧

#### 3.2 手动滚动测试

**测试方法：把机器人架空（轮子不着地），用手转动追踪轮。**

临时在 `autonomous()` 中加入如下代码来打印追踪轮读数：

```cpp
void autonomous() {
    while (true) {
        double fwd_d = tracking_get_forward_distance_m();
        double lat_d = tracking_get_lateral_distance_m();
        Brain.Screen.clearScreen();
        Brain.Screen.setCursor(1, 1);
        Brain.Screen.print("Fwd dist: %.4f m", fwd_d);
        Brain.Screen.setCursor(2, 1);
        Brain.Screen.print("Lat dist: %.4f m", lat_d);
        wait(50, msec);
    }
}
```

| # | 检查项 | 预期 | 如果不正常 |
|---|--------|------|-----------|
| 1 | 向前滚纵向追踪轮 | Fwd dist 增大 | 在 `config.h` 设 `FORWARD_TRACKING_REVERSED = true` |
| 2 | 向左滚横向追踪轮 | Lat dist 增大 | 在 `config.h` 设 `LATERAL_TRACKING_REVERSED = true` |
| 3 | 滚一整圈 (2.75" 轮) | 读数 ≈ 0.2195 m | 检查 `TRACKING_WHEEL_DIAMETER` 是否正确 |
| 4 | 两个传感器独立 | 滚一个不影响另一个 | 检查接线有没有交叉 |

#### 3.3 精度验证

用尺子量 **正好 1 米** 的距离，在地面做标记：

1. 把机器人放在起点
2. 手动沿直线推行 1 米到终点 → 检查纵向轮读数
3. 手动横向推行 1 米 → 检查横向轮读数

**期望值：读到 0.98~1.02 m（±2% 误差）**

如果误差 > 5%：
- 检查轮子直径测量是否准确
- 检查轮子是否打滑（贴地不紧）
- 检查旋转传感器的轴是否松动

### ✅ 通过标准
- 两个追踪轮连接正常（无警告）
- 方向正确（前进/左移 = 正值）
- 推行 1 米，读数误差 < 2%

---

## 阶段 4：里程计验证

### 目标
确认里程计系统正确融合垂直双追踪轮和 IMU 数据，位姿估计准确。

### 前提
阶段 1~3 全部通过。

### 软件验证

恢复正常的 `autonomous()` 代码（删除阶段 3 的临时代码）。

#### 4.1 直线测试

1. 把机器人放在 (0, 0)，朝 X 正方向
2. 用手推着直线走 **正好 1 米**
3. 看 Brain 屏幕：

```
预期: X ≈ 1.00 m,  Y ≈ 0.00 m,  Heading ≈ 0°
```

| 精度要求 | 合格 | 优秀 |
|---------|------|------|
| X 误差 | < 3 cm | < 1 cm |
| Y 漂移 | < 3 cm | < 1 cm |

#### 4.2 转弯测试

1. 放在 (0, 0)
2. 用手原地逆时针转 **正好 90°**（用地面标记辅助）
3. 看 Brain 屏幕：

```
预期: X ≈ 0.00 m,  Y ≈ 0.00 m,  Heading ≈ 90°
```

#### 4.3 矩形测试（最重要）

**这是里程计精度的终极测试。**

1. 在地面贴一个 1m × 1m 的正方形标记
2. 机器人放在起点
3. 用手推着走完一个正方形：前进 1m → 左转 90° → 前进 1m → 左转 90° → 前进 1m → 左转 90° → 前进 1m → 左转 90°
4. 回到起点

```
预期: X ≈ 0.00 m,  Y ≈ 0.00 m,  Heading ≈ 0°（或 360°）
```

| 精度要求 | 合格 | 优秀 |
|---------|------|------|
| 位置误差 | < 10 cm | < 3 cm |
| 角度误差 | < 10° | < 3° |

#### 4.4 如果误差太大

| 症状 | 可能原因 | 解决方案 |
|------|---------|---------|
| X/Y 比例不对 | `TRACKING_WHEEL_DIAMETER` 不准 | 重新测量轮子直径 |
| 转弯时位移不为零 | `FORWARD_WHEEL_OFFSET` 或 `LATERAL_WHEEL_OFFSET` 不准 | 重新测量追踪轮相对旋转中心的偏移量 |
| 直线漂移 | 纵向追踪轮安装歪斜 | 物理调整追踪轮安装方向 |
| 角度漂移 | IMU 漂移（正常现象） | IMU 定期重新校准，或加入视觉定位校正 |

#### 4.5 参数微调方法

**轮径校正：**
```
实际距离 = 1.000 m
里程计读数 = 0.980 m
校正因子 = 1.000 / 0.980 = 1.0204
新轮径 = TRACKING_WHEEL_DIAMETER × 1.0204
```

**偏移量校正：**
```
如果原地转弯时 X 或 Y 读数有偏移：
1. 原地转 360°，记录 X 和 Y 的最终误差
2. 微调 FORWARD_WHEEL_OFFSET 和 LATERAL_WHEEL_OFFSET
3. 重复测试，直到原地转弯时 X/Y 不变
```

### ✅ 通过标准
- 直线 1m 位置误差 < 3 cm
- 转弯 90° 角度误差 < 5°
- 矩形测试回到起点误差 < 10 cm

---

## 阶段 5：PID 转弯调参

### 目标
让机器人能精确地原地转到指定角度。

### 前提
阶段 4 通过（里程计准确）。

### 调参步骤

#### 5.1 准备测试代码

在 `autonomous()` 中写入：

```cpp
void autonomous() {
    hal_log("=== Turn PID Test ===");

    // 原地转 90°
    turn_to_heading(M_PI / 2.0);
    wait(1000, msec);  // 停 1 秒观察

    // 转回 0°
    turn_to_heading(0.0);
    wait(1000, msec);

    // 转 180°
    turn_to_heading(M_PI);
    wait(1000, msec);

    // 回到 0°
    turn_to_heading(0.0);
}
```

#### 5.2 调参三步法

**所有参数在 `config.h` 第 5 节修改。**

##### 第一步：只调 P（设 I=0, D=0）

```cpp
constexpr double TURN_KP = 2.0;   // 从 2.0 开始
constexpr double TURN_KI = 0.0;   // 先设 0
constexpr double TURN_KD = 0.0;   // 先设 0
```

观察表现：

| 现象 | KP 调整 |
|------|--------|
| 转不到位，差很多 | KP 增大 (+0.5) |
| 到位但慢，差一点点 | KP 稍微增大 (+0.2) |
| 过冲明显，来回振荡 | KP 减小 (-0.5) |
| 快速转到位，略有过冲 | ✅ KP 差不多了，进入下一步 |

**目标：转 90° 时快速接近目标，过冲 < 10°**

##### 第二步：加 D（I 仍为 0）

```cpp
constexpr double TURN_KD = 0.1;   // 从 0.1 开始
```

| 现象 | KD 调整 |
|------|--------|
| 仍然振荡 | KD 增大 (+0.1) |
| 反应变迟钝 | KD 减小 (-0.05) |
| 快速到位，无振荡 | ✅ KD 差不多了 |

**目标：无振荡，快速稳定**

##### 第三步：加微量 I

```cpp
constexpr double TURN_KI = 0.01;  // 从 0.01 开始，非常小
```

| 现象 | KI 调整 |
|------|--------|
| 到位后还有 1~2° 的稳态误差 | KI 增大 (+0.01) |
| 开始振荡 | KI 太大了，减小 |
| 精确到位 | ✅ 完成 |

#### 5.3 增强参数调整

```cpp
constexpr double TURN_INTEGRAL_LIMIT = 3.0;    // 防止积分饱和
constexpr double TURN_D_FILTER       = 0.5;    // 平滑微分噪声
```

- **INTEGRAL_LIMIT**：如果 I 项让机器人在转弯后抖动，降低此值
- **D_FILTER**：如果机器人在接近目标时抖动，增大此值（0~1，越大越平滑）

#### 5.4 验证多个角度

| 目标角度 | 精度要求（合格） | 精度要求（优秀） |
|---------|----------------|----------------|
| 90° | 误差 < 3° | 误差 < 1.5° |
| 180° | 误差 < 5° | 误差 < 2° |
| 45° | 误差 < 3° | 误差 < 1.5° |
| -90° | 误差 < 3° | 误差 < 1.5° |

### ✅ 通过标准
- 转 90° 定位时间 < 1 秒
- 稳态误差 < 2°（≈ 0.035 rad）
- 无持续振荡
- 连续 4 次转弯表现一致

---

## 阶段 6：PID 直线调参

### 目标
让机器人能精确地直线行驶到指定距离，同时保持航向。

### 调参步骤

#### 6.1 测试代码

```cpp
void autonomous() {
    hal_log("=== Drive PID Test ===");

    // 前进 1m
    drive_to_pose({1.0, 0.0, 0.0});
    wait(1000, msec);

    // 回到起点
    drive_to_pose({0.0, 0.0, M_PI}, true);  // 倒退
    wait(1000, msec);
}
```

#### 6.2 Boomerang 中的 PID

注意：`drive_to_pose` 内部使用 **转弯 PID** 来修正航向，**不用单独调直线 PID**。
直线速度由运动规划控制（减速曲线 `sqrt(2×a×d)` + 加速度限幅）。

关键参数在 `config.h` 第 6、7 节：

```cpp
// 第 6 节: 直线运动容差
constexpr double DRIVE_SETTLE_M       = 0.015;   // 到位容差 1.5cm
constexpr double DRIVE_SETTLE_TIME_MS = 150;      // 持续在容差内的时间
constexpr double DRIVE_TIMEOUT_MS     = 4000;     // 超时

// 第 7 节: 速度规划
constexpr double MAX_VELOCITY     = 1.2;   // 最大速度 m/s
constexpr double MAX_ACCELERATION = 3.0;   // 最大加速度 m/s²
constexpr double BOOMERANG_LEAD   = 0.6;   // Boomerang 引导系数
```

#### 6.3 调参方法

| 参数 | 作用 | 如何调整 |
|------|------|---------|
| `MAX_VELOCITY` | 最大速度 | 先用 0.5 m/s 慢速调试，正常后逐步增大 |
| `MAX_ACCELERATION` | 加速度 | 先用 1.5 m/s²，太猛则降低 |
| `DRIVE_SETTLE_M` | 到位容差 | 越小越精确但越容易超时 |
| `TURN_KP` (angular PID) | 行驶中航向修正（`drive_to_pose` 复用转弯 PID） | 偏移严重则增大 |

#### 6.4 验证

| # | 测试内容 | 合格 | 优秀 |
|---|---------|------|------|
| 1 | 前进 1m 到位误差 | < 3 cm | < 1.5 cm |
| 2 | 前进时横向漂移 | < 5 cm | < 2 cm |
| 3 | 前进后航向偏差 | < 5° | < 2° |
| 4 | 运动平稳，无急停 | 是 | 是，加减速平滑 |

### ✅ 通过标准
- 1m 直线到位误差 < 3 cm
- 横向漂移 < 5 cm
- 运动过程中无急加急停

---

## 阶段 7：Boomerang 路径验证

### 目标
验证 Boomerang 控制器能驾驶平滑弧线到达任意位姿。

### 测试代码

```cpp
void autonomous() {
    hal_log("=== Boomerang Path Test ===");

    // 测试 1: 直线 + 旋转
    drive_to_pose({1.0, 0.0, 0.0});       // 直线前进 1m
    wait(500, msec);

    // 测试 2: 弧线到达
    drive_to_pose({1.0, 1.0, M_PI / 2.0}); // 弧线到 (1,1)，朝北
    wait(500, msec);

    // 测试 3: 倒车弧线
    drive_to_pose({0.0, 0.0, 0.0}, true);  // 倒车回起点
    wait(500, msec);

    // 测试 4: 大角度弧线
    drive_to_pose({0.5, 1.0, M_PI});       // 弧线到 (0.5, 1)，朝左
}
```

### 验证检查

| # | 检查项 | 预期 |
|---|--------|------|
| 1 | 路径是弧线而非折线 | 机器人画弧到达目标，不先转后走 |
| 2 | 最终航向正确 | 到达后朝向与目标角度一致 |
| 3 | 倒车工作 | reverse=true 时倒着走弧线 |
| 4 | 无超调震荡 | 到达目标后安静停下 |

### BOOMERANG_LEAD 调整

```
BOOMERANG_LEAD = 0.0  → 直线到目标（不管最终朝向）
BOOMERANG_LEAD = 0.3  → 轻微弧线
BOOMERANG_LEAD = 0.6  → 中等弧线（推荐起点）
BOOMERANG_LEAD = 1.0  → 强弧线（大回旋）
```

- 如果弧线太大导致偏离赛场 → 减小 LEAD
- 如果到达时朝向差 → 增大 LEAD

### ✅ 通过标准
- 弧线路径平滑
- 到达位姿误差 < 5 cm（位置）+ < 10°（航向）
- 倒车功能正常
- 4 秒内完成 1m 距离的弧线运动

---

## 阶段 8：视觉定位（可选）

### 目标
使用 AprilTag 绝对定位修正里程计漂移。

### 硬件接线

在阶段 7 基础上，加入：

| 设备 | 端口 | 备注 |
|------|-----|------|
| AI 视觉传感器 | Port 12 | 安装在机器人前方，朝前 |

### 场地准备

在赛场四周贴 AprilTag 标签，并在 `vision_localizer.cpp` 的 `FIELD_TAGS[]` 数组中填入每个标签的：
- `id` — 标签 ID
- `x, y` — 在场上的坐标（米）
- `z` — 标签离地面的高度（米），用于距离估算
- `facing` — 标签朝向（弧度，法线方向）

### 验证步骤

#### 8.1 连接确认

Brain 屏幕 `Vision tags: X` 应随看到的标签数变化：
- 面对标签 → `Vision tags: 1`
- 远离标签 → `Vision tags: 0`

#### 8.2 定位精度测试

1. 把机器人放在已知位置（如 (1.0, 1.0)）
2. 设 `set_pose({1.0, 1.0, 0.0})`
3. 运行里程计一段时间
4. 检查 Vision 修正后位姿是否更准

### 调整参数

```cpp
// config.h 第 10 节
constexpr double VISION_CORRECTION_ALPHA = 0.4;  // 修正强度 (0=不修正, 1=完全信任视觉)
constexpr double VISION_MAX_CORRECTION_M = 0.30;  // 单次最大修正量
constexpr double VISION_MIN_CONFIDENCE   = 0.15;  // 最低置信度阈值
```

### ✅ 通过标准
- 能检测到 AprilTag
- 视觉修正减小了里程计漂移（而非增大）
- 修正后无明显跳变

---

## 阶段 9：完整自治路线

### 目标
编写完整的比赛自治路线，在赛场上测试。

### 步骤

#### 9.1 规划路线

1. 在赛场图上标出所有目标位置
2. 确定经过顺序
3. 注意机器人的最终朝向

#### 9.2 编写路线

```cpp
void autonomous() {
    hal_log("=== Match Autonomous ===");

    // 起始位姿（根据起点调整）
    set_pose({0.3, 0.3, 0.0});

    // 路径点 1: 到第一个目标
    drive_to_pose({1.0, 0.3, 0.0});

    // 路径点 2: 转向并前进
    drive_to_pose({1.0, 1.0, M_PI / 2.0});

    // 路径点 3: 继续...
    turn_to_heading(M_PI);
    drive_to_pose({0.3, 1.0, M_PI});

    // ... 根据比赛策略继续编写
}
```

#### 9.3 使用 SD 卡日志分析

程序自动在 SD 卡上生成 `odom_log.csv`：

```csv
time_ms,x,y,theta,error
100,0.001,0.000,0.001,0.999
200,0.015,0.001,0.002,0.985
...
```

在电脑上用 Excel 或 Python 打开，画出轨迹：

```python
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('odom_log.csv')
plt.plot(df['x'], df['y'], '-o', markersize=2)
plt.axis('equal')
plt.xlabel('X (m)')
plt.ylabel('Y (m)')
plt.title('Robot Trajectory')
plt.grid(True)
plt.show()
```

#### 9.4 迭代优化

1. 跑一次自治 → 看 CSV 轨迹
2. 找偏差最大的点 → 调参或调路径
3. 重复直到满意

### ✅ 通过标准
- 完整自治路线在 15 秒内完成（比赛限时）
- 每个路径点到位误差 < 5 cm
- 重复 5 次，一致性 > 80%

---

## 阶段 10：比赛就绪检查清单

### 赛前检查

| # | 检查项 | 状态 |
|---|--------|------|
| 1 | 电池充电 > 80% | ☐ |
| 2 | 所有电机用 Brain 检测到 | ☐ |
| 3 | IMU 校准通过（无 TIMEOUT） | ☐ |
| 4 | 两个追踪轮连接正常（纵向 + 横向） | ☐ |
| 5 | 手柄连接正常，操控灵敏 | ☐ |
| 6 | 自治测试跑 3 次，结果一致 | ☐ |
| 7 | SD 卡已插入（记录日志） | ☐ |
| 8 | 所有螞丝拧紧 | ☐ |
| 9 | 追踪轮弹簧贴地（纵向和横向都检查） | ☐ |
| 10 | 起始位姿 `set_pose()` 已设为正确值 | ☐ |

### 机械检查

| # | 检查项 | 状态 |
|---|--------|------|
| 1 | 轮子无松动 | ☐ |
| 2 | 齿轮无异响 | ☐ |
| 3 | 线缆不会被压住或夹住 | ☐ |
| 4 | 电池固定牢固 | ☐ |
| 5 | 机器人尺寸在规则范围内 | ☐ |

---

## 附录 A：常见问题排查表

| # | 症状 | 可能原因 | 解决方案 |
|---|------|---------|---------|
| 1 | 电机不转 | 端口没接对 / 线缆松动 | 检查 `config.h` 端口号，重新插线 |
| 2 | 一侧电机方向反 | 电机 reversed 设置错误 | 在 `main.cpp` 中翻转该电机的 `true/false` |
| 3 | IMU 校准超时 | 传感器没插好 / 端口错误 | 检查 Port 10 接线 |
| 4 | 追踪轮读数不动 | 旋转传感器没连接 | 检查 Port 8/9，确认传感器指示灯亮 |
| 5 | 追踪轮方向反 | reversed 设错 | `config.h` 设 `FORWARD/LATERAL_TRACKING_REVERSED` |
| 6 | 里程计直线漂移 | 纵向追踪轮安装歪斜 / 轮径不准 | 物理调整 + 校正 `TRACKING_WHEEL_DIAMETER` |
| 7 | 里程计转弯时位置跳变 | 追踪轮偏移量不准 | 校正 `FORWARD_WHEEL_OFFSET` 和 `LATERAL_WHEEL_OFFSET` |
| 8 | 转弯振荡 | KP 太大 或 KD 太小 | 减 KP，加 KD |
| 9 | 转弯到不了位 | KP 太小 或 无 KI | 加 KP，加微量 KI |
| 10 | 直线时拐弯 | 单侧电机问题 / 航向修正不够 | 检查电机，加大 `TURN_KP`（`drive_to_pose` 复用转弯 PID） |
| 11 | 自治路线偏差大 | 里程计累积误差 | 增加 Vision 修正，缩短路径段 |
| 12 | Brain 黑屏 | 程序崩溃 | 检查编译警告，简化代码逐步调试 |
| 13 | SD 卡无日志 | SD 卡未格式化/未插好 | 用 FAT32 格式化，重新插入 |
| 14 | 电机过热 | 负载过大 / 齿轮卡住 | 检查机械，降低电压上限 |

---

## 附录 B：调参速查表

### 推荐调参起点

| 参数 | 初始值 | 范围 | 说明 |
|------|-------|------|------|
| **TURN_KP** | 2.0 | 1.0~8.0 | 转弯 P，最先调 |
| **TURN_KI** | 0.0 | 0.0~0.1 | 转弯 I，最后调，非常小 |
| **TURN_KD** | 0.0 | 0.0~1.0 | 转弯 D，第二调 |
| **TURN_INTEGRAL_LIMIT** | 3.0 | 1.0~10.0 | I 项上限 |
| **TURN_D_FILTER** | 0.5 | 0.0~0.9 | D 滤波，越大越平滑 |
| **MAX_VELOCITY** | 0.5 | 0.3~1.3 | 先慢后快 |
| **MAX_ACCELERATION** | 1.5 | 1.0~5.0 | 先柔后猛 |
| **BOOMERANG_LEAD** | 0.6 | 0.0~1.0 | 弧线程度 |
| **IMU_FUSION_ALPHA** | 0.98 | 0.8~1.0 | 越大越信任 IMU |
| **DRIVE_SETTLE_M** | 0.015 | 0.01~0.05 | 到位容差 |

### 调参策略总结

```
1. 先确保硬件正常（阶段 1~3）
2. 先确保里程计准确（阶段 4）
3. 先转弯 PID（阶段 5）：P → D → I
4. 再直线运动（阶段 6）：速度 → 加速度 → 容差
5. 最后弧线路径（阶段 7）：BOOMERANG_LEAD
6. 每次只改一个参数
7. 每次改完跑 3 遍确认一致性
```

---

> **记住：耐心是调参的核心品质。每个阶段都彻底通过后再进入下一阶段，会让你在比赛日省下大量时间。**
